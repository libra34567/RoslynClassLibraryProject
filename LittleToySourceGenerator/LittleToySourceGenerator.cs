using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using CsCodeGenerator;
using CsCodeGenerator.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace LittleToySourceGenerator;

[Generator]
public class Generator : ISourceGenerator
{
    public bool EnableEventDataGeneration { get; set; } = true;
    public bool EnableEventSystemGeneration { get; set; } = true;
    public bool GenerateEventViewInterfaceGeneration { get; set; } = true;
    public bool EnableReadWriteEcsGeneration { get; set; } = true;
    public bool EnableNetMessageGeneration { get; set; } = true;
    public bool EnableNetworkComponentGeneration { get; set; } = true;
    public bool EnableSelectiveSystemAuthoringGeneration { get; set; } = true;

    public const string ComponentDirtyEventAttributeType = "ComponentDirtyEvent";

    public const string CodeGenNetComponentAttributeType = "CodeGenNetComponent";

    public const string MarkDirtyAttributeType = "MarkDirty";

    public const string SyncFieldAttributeType = "SyncField";

    public const string ComponentRemovedEventAttributeType = "ComponentRemovedEvent";

    public const string ComponentAddedEventAttributeType = "ComponentAddedEvent";

    public const string ReadWriteEcsAttributeType = "ReadWriteEcs";

    public const string HasComponentEcsAttributeType = "HasComponentEcs";
    public const string OnAddedEventViewAttributeType = "OnAddedEventView";
    public const string OnRemovedEventViewAttributeType = "OnRemovedEventView";
    public const string OnDirtyEventViewAttributeType = "OnDirtyEventView";
    public const string CodeGenNetMessageAttributeType = "CodeGenNetMessage";
    public const string GenerateSystemAuthoringAttributeType = "GenerateSystemAuthoring";
    public const string FieldFromAuthoringAttributeType = "FieldFromAuthoring";
    public const string ServerWorldAttributeType = "ServerWorld";
    public const string ClientWorldAttributeType = "ClientWorld";
    public const string DisableAutoCreationAttributeType = "DisableAutoCreation";

    public const string FileHeader = @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591";

    private static DiagnosticDescriptor FieldTypeShouldBeKnownForDotsNet = new DiagnosticDescriptor(
        "LT0001",
        "Field type should be known to DOTSNET", 
        "Cannot convert field type {0} to dotsnet read/write methods",
        "LittleToy",
        DiagnosticSeverity.Error, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static DiagnosticDescriptor NetComponentShouldHaveSyncField = new DiagnosticDescriptor(
        "LT0002",
        "Net component should have SyncField",
        "Type {0} does not have any field marked with SyncFieldAttribute",
        "LittleToy",
        DiagnosticSeverity.Error, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static DiagnosticDescriptor EventSystemTypesShouldHaveAttribute = new DiagnosticDescriptor(
        "LT0003",
        "EventSystem types should use appropriate types",
        "Type {0} used with {1} attribute but do not marked with {2}.",
        "LittleToy",
        DiagnosticSeverity.Warning, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static DiagnosticDescriptor FatalError = new DiagnosticDescriptor(
        "LT0004",
        "Fatal error happens",
        "Exception of type {0} produce following message {1} at {2}.",
        "LittleToy",
        DiagnosticSeverity.Error, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static Dictionary<string, string> _systemToDotsnetTypeDictionary = new Dictionary<string, string>()
    {
        { "System.Byte", "Byte"},
        { "System.Boolean", "Bool"},
        { "System.Int16", "Short"},
        { "System.UInt16", "UShort"},
        { "System.Int32", "Int"},
        { "System.UInt32", "UInt"},
        { "Unity.Mathematics.int2", "Int2" },
        { "Unity.Mathematics.int3", "Int3" },
        { "Unity.Mathematics.int4", "Int4" },
        { "System.UInt64", "ULong" },
        { "System.Int64", "Long" },
        { "DOTSNET.long3", "Long3" },
        { "System.Single", "Float" },
        { "Unity.Mathematics.float2", "Float2" },
        { "Unity.Mathematics.float3", "Float3" },
        { "Unity.Mathematics.float4", "Float4" },
        { "System.Double", "Double"},
        { "Unity.Mathematics.double2", "Double2" },
        { "Unity.Mathematics.double3", "Double3" },
        { "Unity.Mathematics.double4", "Double4" },
        { "System.Decimal", "Decimal"},
        { "Unity.Mathematics.quaternion", "Quaternion"},
        { "Unity.Collections.FixedBytes16", "Bytes16"},
        { "Unity.Collections.FixedBytes30", "Bytes30"},
        { "Unity.Collections.FixedBytes62", "Bytes62"},
        { "Unity.Collections.FixedBytes126", "Bytes126"},
        { "Unity.Collections.FixedBytes510", "Bytes510"},
        { "Unity.Collections.FixedBytes4094", "Bytes4094"},
        { "Unity.Collections.FixedString32Bytes", "FixedString32"},
        { "Unity.Collections.FixedString64Bytes", "FixedString64"},
        { "Unity.Collections.FixedString128Bytes", "FixedString128"},
        { "Unity.Collections.FixedString512Bytes", "FixedString512"},
        { "Unity.Collections.FixedList32Bytes<T>", "FixedList32Batched"},
        { "Unity.Collections.FixedList64Bytes<T>", "FixedList64Batched"},
        { "Unity.Collections.FixedList128Bytes<T>", "FixedList128Batched"},
        { "Unity.Collections.FixedList512Bytes<T>", "FixedList512Batched"}
    };

    public void DisableAllGeneration()
    {
        EnableEventDataGeneration = false;
        EnableEventSystemGeneration = false;
        GenerateEventViewInterfaceGeneration = false;
        EnableReadWriteEcsGeneration = false;
        EnableNetMessageGeneration = false;
        EnableNetworkComponentGeneration = false;
        EnableSelectiveSystemAuthoringGeneration = false;
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        try
        {
            if (EnableEventDataGeneration)
            {
                GenerateEventDataFiles(context, receiver);
            }

            if (EnableEventSystemGeneration)
            {
                GenerateEventSystemFiles(context, receiver);
            }

            if (GenerateEventViewInterfaceGeneration)
            {
                GenerateEventViewInterfaceFiles(context, receiver);
            }

            if (EnableReadWriteEcsGeneration)
            {
                GenerateReadWriteEcsFiles(context, receiver);
                GenerateHasComponentEcsFiles(context, receiver);
            }

            if (EnableNetMessageGeneration)
            {
                GenerateNetMessageFiles(context, receiver);
            }

            if (EnableNetworkComponentGeneration)
            {
                GenerateNetworkComponentFiles(context, receiver);
            }

            if (EnableSelectiveSystemAuthoringGeneration)
            {
                var selectiveSystemsGenerator = new SelectiveSystemAuthoringGenerator(receiver.SelectiveSystems, context);
                selectiveSystemsGenerator.Execute();
            }
        }
        catch (Exception ex)
        {
            var err = Diagnostic.Create(FatalError, location: null, ex.GetType().Name, ex.Message, ex.StackTrace);
            context.ReportDiagnostic(err);
        }
    }

    private static void GenerateEventDataFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateEventData(typeSymbol, context, type);
            context.AddSource(typeSymbol.Name + "EventData", SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateEventData(ITypeSymbol eventComponentType, GeneratorExecutionContext context, SyntaxNode syntaxNode)
    {
        var file = new FileModel(eventComponentType.Name + "EventData")
        {
            UsingDirectives = new List<string>
            {
                "System;",
                "Unity.Entities;",
                "Unity.Mathematics;",
                "Plugins.basegame.Events;",
                "DOTSNET;",
                "Unity.Collections;"
            },
            Namespace = eventComponentType.ContainingNamespace.GetNamespace(),
            Header = FileHeader,
        };

        // Generate methods and properties used for dirty event of ComponentData
        if (eventComponentType.HasAttribute(ComponentDirtyEventAttributeType) || eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            // Create the StructModel used for code generation
            file.Structs.Add(GenerateEventStructModel(eventComponentType, context, syntaxNode));
        }

        // Generate listeners required for each type of event add/remove/dirty
        file.Interfaces.Add(GenerateComponentDirtyEventInterfaceModel(eventComponentType));
        file.Interfaces.Add(GenerateComponentRemovedEventInterfaceModel(eventComponentType));
        file.Interfaces.Add(GenerateComponentAddedEventInterface(eventComponentType));
        return file;
    }

    /// <summary>
    /// Generate the struct model used for code generation
    /// </summary>
    /// <param name="eventComponentType">Component type for which generate EventData structure implementation.</param>
    /// <param name="context">Code generation context in which generate the struct.</param>
    /// <param name="syntaxNode">Syntax node for which attempt to generate code happens.</param>
    /// <returns>A <see cref="StructModel"/> representing generated component.</returns>
    private static StructModel GenerateEventStructModel(ITypeSymbol eventComponentType, GeneratorExecutionContext context, SyntaxNode syntaxNode)
    {
        //Only generate IfDirty Property if there's any field marked with [MarkDirty] attribute
        var needIfDirty = false;
        var modelsFromFields = eventComponentType.GetFields().Select(field => new EventComponentFieldModel(field));
        var modelsFromProperties = eventComponentType.GetProperties().Select(property => new EventComponentFieldModel(property));
        IEnumerable<EventComponentFieldModel> fieldInfos = modelsFromFields.Union(modelsFromProperties).ToList();
        foreach (var fieldInfo in fieldInfos)
        {
            if (fieldInfo.HasMarkDirtyAttribute)
            {
                needIfDirty = true;
                break;
            }
        }

        var structModel = new StructModel(eventComponentType.Name)
        {
            SingleKeyWord = KeyWord.Partial,
            Properties = new List<Property>(),
            Interfaces = new List<string>()
        };

        if (needIfDirty)
        {
            structModel.Properties.Add(new Property(BuiltInDataType.Bool, "IsDirty")
            {
                AccessModifier = AccessModifier.Public
            });
        }

        // Implement NetworkComponent interface if has attribute CodeGenNetComponent
        if (eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            structModel.Interfaces.Add("NetworkComponent");
        }

        // Generate update method, when there's at least one field with MarkDirty and without SyncField attribute
        // the Update method used to update the fields/properties of the struct then mark the struct as dirty.
        List<EventComponentFieldModel> fieldsWithMarkDirtyAndWithoutSyncField = new();
        foreach (var fieldInfo in fieldInfos)
        {
            if (fieldInfo.HasMarkDirtyAttribute &&
                fieldInfo.HasSyncFieldAttribute == false)
            {
                fieldsWithMarkDirtyAndWithoutSyncField.Add(fieldInfo);
            }
        }

        if (fieldsWithMarkDirtyAndWithoutSyncField.Count > 0)
        {
            var method = new Method(BuiltInDataType.Void, "Update")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>(),
                BodyLines = new List<string>()
                {
                    "if(",
                    "",
                    "IsDirty = true;"
                },
                CustomDataType = eventComponentType.ToDisplayString()
            };

            var isFirst = true;

            // The body of the update method
            foreach (var fieldInfo in fieldsWithMarkDirtyAndWithoutSyncField)
            {
                string parameterName = fieldInfo.Name.LowerFirst();
                if (parameterName == fieldInfo.Name)
                {
                    parameterName += "_";
                }

                method.Parameters.Add(new Parameter()
                {
                    CustomDataType = fieldInfo.Type.ToDisplayString(),
                    Name = parameterName
                });

                if (!isFirst)
                    method.BodyLines[0] += " && ";

                method.BodyLines[0] += $"{fieldInfo.Name}.Equals({parameterName})";
                isFirst = false;

                method.BodyLines.Add($"{fieldInfo.Name} = {parameterName};");
            }

            method.BodyLines[0] += ") return this;";

            method.BodyLines.Add("");
            method.BodyLines.Add("return this;");

            structModel.Methods.Add(method);
        }

        if (eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            // Generate the GetSyncDirection Method
            var syncDir = eventComponentType.GetCustomAttribute(CodeGenNetComponentAttributeType).GetFieldValue("SyncDirection");
            var GetSyncDirectionMethodModel = new Method("SyncDirection", "GetSyncDirection")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>(),
                BodyLines = new List<string>()
                {
                    $"return SyncDirection.{syncDir.ToString()};"
                },
            };
            structModel.Methods.Add(GetSyncDirectionMethodModel);

            // Get syncField field list
            var fieldWithSyncFieldAttribute = new List<EventComponentFieldModel>();
            var fieldWithSyncFieldAndMarkDirtyAttribute = new List<EventComponentFieldModel>();

            foreach (var fieldInfo in fieldInfos)
            {
                if (fieldInfo.HasSyncFieldAttribute)
                {
                    fieldWithSyncFieldAttribute.Add(fieldInfo);
                    if (fieldInfo.HasMarkDirtyAttribute)
                    {
                        fieldWithSyncFieldAndMarkDirtyAttribute.Add(fieldInfo);
                    }
                }
            }

            if (fieldWithSyncFieldAttribute.Count == 0)
            {
                var err = Diagnostic.Create(NetComponentShouldHaveSyncField, location: syntaxNode.GetLocation(), eventComponentType.Name);
                context.ReportDiagnostic(err);
            }

            // Perform validation
            for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
            {
                var fieldInfo = fieldWithSyncFieldAttribute[i];
                var fieldType = fieldInfo.Type;

                if (IsDotsnetCompatibleType(fieldType) == false)
                {
                    var err = Diagnostic.Create(FieldTypeShouldBeKnownForDotsNet, location: syntaxNode.GetLocation(), fieldType.Name);
                    context.ReportDiagnostic(err);
                    return structModel;
                }
            }

            var serializeMethodModel = new Method(BuiltInDataType.Bool, "Serialize")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>
                {
                    new Parameter("ref NetworkWriter128 writer")
                },
                BodyLines = new List<string>(),
            };

            for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
            {
                var fieldInfo = fieldWithSyncFieldAttribute[i];
                var fieldType = fieldInfo.Type;

                var conversion = IsDotsnetType(fieldType)
                    ? string.Empty
                    : $"({GetDotsnetCompatibleType(fieldType).ToDisplayString()})";
                if (IsDotsnetFixedList(fieldType))
                {
                    serializeMethodModel.BodyLines.Add($"if (!DotsNetworkExtension.Write{GetDotsnetTypeName(fieldType)}(ref writer, in {fieldInfo.Name})) return false;");
                }
                else
                {
                    serializeMethodModel.BodyLines.Add($"if (!writer.Write{GetDotsnetTypeName(fieldType)}({conversion}{fieldInfo.Name})) return false;");
                }
            }

            serializeMethodModel.BodyLines.Add($"return true;");
            structModel.Methods.Add(serializeMethodModel);

            var allFieldsIsDotsNetTypes = fieldWithSyncFieldAttribute.All(f => IsDotsnetType(f.Type) && !f.IsProperty);
            var shouldDealWithDirtyInDeserialize = fieldWithSyncFieldAndMarkDirtyAttribute.Count > 0;
            var deserializeMethodModel = new Method(BuiltInDataType.Bool, "Deserialize")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter> { new Parameter("ref NetworkReader128 reader") },
            };

            deserializeMethodModel.BodyLines = new List<string>();
            
            for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
            {
                var fieldInfo = fieldWithSyncFieldAttribute[i];
                var fieldType = fieldInfo.Type;
                var hasSyncFieldAndMarkDirty = fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo);
                string fieldName;
                if (hasSyncFieldAndMarkDirty || !IsDotsnetType(fieldType) || fieldInfo.IsProperty)
                {
                    deserializeMethodModel.BodyLines.Add(
                        $"{GetDotsnetCompatibleType(fieldType)} {fieldInfo.Name.ToCamel()} = default;");
                    fieldName = fieldInfo.Name.ToCamel();
                }
                else
                {
                    fieldName = fieldInfo.Name;
                }

                if (IsDotsnetFixedList(fieldType))
                {
                    deserializeMethodModel.BodyLines.Add(
                        $"if (!DotsNetworkExtension.Read{GetDotsnetTypeName(fieldType)}(ref reader, ref {fieldName})) return false;");
                }
                else
                {
                    deserializeMethodModel.BodyLines.Add(
                        $"if (!reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldName})) return false;");
                }
            }

            if (!allFieldsIsDotsNetTypes || shouldDealWithDirtyInDeserialize)
            {
                deserializeMethodModel.BodyLines.Add(string.Empty);
            }

            foreach (var fieldInfo in fieldWithSyncFieldAttribute)
            {
                if (fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo))
                {
                    continue;
                }

                if (IsDotsnetType(fieldInfo.Type) && !fieldInfo.IsProperty)
                {
                    continue;
                }

                if (IsDotsnetFixedList(fieldInfo.Type) || (fieldInfo.IsProperty && fieldInfo.Type.TypeKind != TypeKind.Enum))
                {
                    deserializeMethodModel.BodyLines.Add($"{fieldInfo.Name} = {fieldInfo.Name.ToCamel()};");
                }
                else
                {
                    deserializeMethodModel.BodyLines.Add($"{fieldInfo.Name} = ({fieldInfo.Type.ToDisplayString()}){fieldInfo.Name.ToCamel()};");
                }
            }

            if (shouldDealWithDirtyInDeserialize || !allFieldsIsDotsNetTypes)
            {
                if (shouldDealWithDirtyInDeserialize)
                {
                    deserializeMethodModel.BodyLines.Add("var unchanged = true;");

                    for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
                    {
                        var fieldInfo = fieldWithSyncFieldAttribute[i];
                        var fieldType = fieldInfo.Type;

                        var hasSyncFieldAndMarkDirty = fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo);
                        var conversion = IsDotsnetType(fieldType) || IsDotsnetFixedList(fieldType) ? string.Empty : $"({fieldType.ToDisplayString()})";
                        var comparison = $"if (unchanged && {fieldInfo.Name} != {conversion}{fieldInfo.Name.ToCamel()}) unchanged = false;";
                        if (hasSyncFieldAndMarkDirty)
                        {
                            deserializeMethodModel.BodyLines.Add(comparison);
                        }
                    }

                    deserializeMethodModel.BodyLines.Add("if (unchanged) return true;");
                    deserializeMethodModel.BodyLines.Add("IsDirty = true;");
                    deserializeMethodModel.BodyLines.Add(string.Empty);
                }

                for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
                {
                    var fieldInfo = fieldWithSyncFieldAttribute[i];
                    var fieldType = fieldInfo.Type;

                    var hasSyncFieldAndMarkDirty = fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo);
                    var conversion = IsDotsnetType(fieldType) || fieldInfo.IsProperty || IsDotsnetFixedList(fieldType) ? string.Empty : $"({fieldType.ToDisplayString()})";
                    var assignment = $"{fieldInfo.Name} = {conversion}{fieldInfo.Name.ToCamel()};";
                    if (hasSyncFieldAndMarkDirty)
                    {
                        deserializeMethodModel.BodyLines.Add(
                            $"{assignment}");
                    }
                }
            }

            deserializeMethodModel.BodyLines.Add("return true;");
            structModel.Methods.Add(deserializeMethodModel);
        }

        return structModel;
    }

    /// <summary>
    /// Generate listeners required for ComponentData dirty event, this is used in ViewClasses to receive events
    /// </summary>
    /// <param name="eventComponentType">Component type for which generate IXXXListener interface declaration.</param>
    /// <returns>An <see cref="InterfaceModel"/> for generated IXXXListener interface or null if interface would not be generated.</returns>
    private static InterfaceModel GenerateComponentDirtyEventInterfaceModel(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentDirtyEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);

        var interfaceModel = new InterfaceModel($"I{nameRoot}Listener")
        {
            AccessModifier = AccessModifier.Public
        };
        var method = new Method(BuiltInDataType.Void, $"On{nameRoot}Changed")
        {
            Parameters = new List<Parameter>(),
            WithoutBody = true
        };

        var modelsFromFields = eventComponentType.GetFields().Select(field => new EventComponentFieldModel(field));
        var modelsFromProperties = eventComponentType.GetProperties().Select(property => new EventComponentFieldModel(property));
        IEnumerable<EventComponentFieldModel> fieldInfos = modelsFromFields.Union(modelsFromProperties).ToList();
        foreach (var fieldInfo in fieldInfos)
        {
            if (fieldInfo.Name == "IsDirty" || !fieldInfo.HasMarkDirtyAttribute)
            {
                continue;
            }

            method.Parameters.Add(new Parameter()
            {
                CustomDataType = fieldInfo.Type.ToDisplayString(),
                Name = fieldInfo.Name.LowerFirst()
            });
        }

        interfaceModel.Methods.Add(method);
        return interfaceModel;
    }

    // Generate listeners required for ComponentData removed event, this is used in ViewClasses to receive events
    private static InterfaceModel GenerateComponentRemovedEventInterfaceModel(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentRemovedEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var interfaceModel = new InterfaceModel($"I{nameRoot}RemovedListener")
        {
            AccessModifier = AccessModifier.Public,
            Methods = new List<Method>
            {
                new Method(BuiltInDataType.Void, $"On{nameRoot}Removed")
                {
                    Parameters = new List<Parameter>(),
                    WithoutBody = true
                }
            }
        };

        return interfaceModel;
    }

    // Generate listeners required for ComponentData added event, this is used in ViewClasses to receive events
    private static InterfaceModel GenerateComponentAddedEventInterface(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentAddedEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var interfaceModel = new InterfaceModel($"I{nameRoot}AddedListener")
        {
            AccessModifier = AccessModifier.Public,
            Methods = new List<Method>
            {
                new Method(BuiltInDataType.Void, $"On{nameRoot}Added")
                {
                    Parameters = new List<Parameter>(),
                    WithoutBody = true
                }
            }
        };

        return interfaceModel;
    }

    private static string GetFullyQualifiedName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.SpecialType switch
        {
            SpecialType.System_Byte => "System.Byte",
            SpecialType.System_Boolean => "System.Boolean",
            SpecialType.System_SByte => "System.SByte",
            SpecialType.System_Single => "System.Single",
            SpecialType.System_Double => "System.Double",
            SpecialType.System_Decimal => "System.Decimal",
            SpecialType.System_Int16 => "System.Int16",
            SpecialType.System_Int32 => "System.Int32",
            SpecialType.System_Int64 => "System.Int64",
            SpecialType.System_UInt16 => "System.UInt16",
            SpecialType.System_UInt32 => "System.UInt32",
            SpecialType.System_UInt64 => "System.UInt64",
            _ => typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty),
        };
    }

    private static bool IsDotsnetCompatibleType(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
        {
            if (typeSymbol.TypeKind == TypeKind.Enum)
            {
                typeSymbol = namedTypeSymbol.EnumUnderlyingType;
            }

            if (namedTypeSymbol.IsGenericType)
            {
                typeSymbol = namedTypeSymbol.ConstructedFrom;
            }
        }

        return IsDotsnetType(typeSymbol);
    }

    private static bool IsDotsnetFixedList(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
        {
            if (namedTypeSymbol.IsGenericType)
            {
                return true;
            }
        }

        return false;
    }

    private static ITypeSymbol GetDotsnetCompatibleType(ITypeSymbol typeSymbol)
    {
        if (typeSymbol.TypeKind == TypeKind.Enum)
        {
            return ((INamedTypeSymbol)typeSymbol).EnumUnderlyingType;
        }

        return typeSymbol;
    }

    private static bool IsDotsnetType(ITypeSymbol typeSymbol)
    {
        return _systemToDotsnetTypeDictionary.ContainsKey(GetFullyQualifiedName(typeSymbol));
    }

    private static string GetDotsnetTypeName(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
        {
            if (typeSymbol.TypeKind == TypeKind.Enum)
            {
                typeSymbol = namedTypeSymbol.EnumUnderlyingType;
            }

            if (namedTypeSymbol.IsGenericType)
            {
                typeSymbol = namedTypeSymbol.ConstructedFrom;
            }
        }

        return _systemToDotsnetTypeDictionary[GetFullyQualifiedName(typeSymbol)];
    }

    private static void GenerateEventSystemFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        Dictionary<ITypeSymbol, SyntaxNode> componentUserFiles = new();
        foreach (var type in receiver.ComponentWithEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            foreach (var attribute in typeSymbol.GetCustomAttributes(true)
                .Where(a => a.IsAttribute(OnDirtyEventViewAttributeType) || a.IsAttribute(OnAddedEventViewAttributeType) || a.IsAttribute(OnRemovedEventViewAttributeType)))
            {
                var fieldTypes = attribute.GetFieldValueTypes("Types");
                foreach (var componentTypeCandidate in fieldTypes)
                {
                    if (!componentUserFiles.ContainsKey(componentTypeCandidate))
                    {
                        componentUserFiles.Add(componentTypeCandidate, type);
                    }
                }
            }
        }

        foreach (var pair in componentUserFiles)
        {
            var typeSymbol = pair.Key;
            var type = pair.Value;
            var file = GenerateEventSystem(context, receiver, type, typeSymbol, context.Compilation.AssemblyName != "Assembly-CSharp-firstpass" ? string.Empty : "BaseGame");
            
            if (file.Classes[0] == null)
            {
                continue;
            }

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }

        foreach (var type in receiver.ComponentWithEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            Validate(OnDirtyEventViewAttributeType, ComponentDirtyEventAttributeType);
            Validate(OnAddedEventViewAttributeType, ComponentAddedEventAttributeType);
            Validate(OnRemovedEventViewAttributeType, ComponentRemovedEventAttributeType);

            void Validate(string marker, string expectedAttribute)
            {
                var onDirtyEventViewAttribute = typeSymbol.GetCustomAttribute(marker, true);
                if (onDirtyEventViewAttribute != null)
                {
                    var typesToCheck = onDirtyEventViewAttribute.GetFieldValueTypes("Types");
                    foreach (var componentDirtyType in typesToCheck)
                    {
                        if (!componentDirtyType.HasAttribute(expectedAttribute))
                        {
                            context.ReportDiagnostic(Diagnostic.Create(EventSystemTypesShouldHaveAttribute, location: type.GetLocation(), componentDirtyType.Name, marker, expectedAttribute));
                            break;
                        }
                    }
                }
            }
        }
    }

    private static FileModel GenerateEventSystem(GeneratorExecutionContext context, SyntaxReceiver receiver, SyntaxNode syntaxNode, ITypeSymbol eventComponentType, string classAddonName)
    {
        var usingDirectives = new List<string>
        {
            "System;",
            "Unity.Collections;",
            "Unity.Entities;",
            "Unity.Mathematics;",
            "Plugins.basegame.Events;",
            "DOTSNET;"
        };

        var file = new FileModel(eventComponentType.Name + "EventSystem" + classAddonName)
        {
            Header = FileHeader,
            Namespace = eventComponentType.ContainingNamespace.GetNamespace(),
        };
        file.LoadUsingDirectives(usingDirectives);

        //the class model used for code generation
        file.Classes.Add(GenerateEventSystemClassModel(context, receiver, syntaxNode, eventComponentType, classAddonName));
        return file;
    }

    private static ClassModel GenerateEventSystemClassModel(GeneratorExecutionContext context, SyntaxReceiver receiver, SyntaxNode syntaxNode, ITypeSymbol eventComponentType, string classAddonName)
    {
        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var classModel = new ClassModel($"{nameRoot}EventSystem" + classAddonName)
        {
            AccessModifier = AccessModifier.Public,
            BaseClass = "SystemBase",
            SingleKeyWord = KeyWord.Partial,
            Fields = new List<Field>(),
            Methods = new List<Method>(),
            NestedClasses = new List<ClassModel>(),
            Attributes = new List<AttributeModel>
            {
                new("UpdateBefore")
                {
                    SingleParameter = new Parameter("typeof(CleanUpAddedRemovedEventSystem)")
                },
                new("ClientWorld"),
                new("UpdateInGroup")
                {
                    Parameters = new List<Parameter>
                    {
                        new("typeof(SimulationSystemGroup)"),
                        new("OrderLast = true")
                    }
                }
            }
        };

        var onCreateMethodModel = new Method(AccessModifier.Protected, KeyWord.Override, BuiltInDataType.Void, "OnCreate");
        onCreateMethodModel.BodyLines.Add("base.OnCreate();");
        classModel.Methods.Add(onCreateMethodModel);

        var onUpdateMethodModel = new Method(AccessModifier.Protected, KeyWord.Override, BuiltInDataType.Void, "OnUpdate");
        classModel.Methods.Add(onUpdateMethodModel);

        List<ClassDeclarationSyntax> classCandidates = receiver.ComponentWithEventStructs;
        var dirtyEventViewTypes = GetDirtyTypes(context.Compilation, eventComponentType, classCandidates, OnDirtyEventViewAttributeType);
        var hasDirtyEventViewTypes = dirtyEventViewTypes.Count > 0;
        var addedEventViewTypes = GetDirtyTypes(context.Compilation, eventComponentType, classCandidates, OnAddedEventViewAttributeType);
        var hasAddedEventViewTypes = addedEventViewTypes.Count > 0;
        var removedEventViewTypes = GetDirtyTypes(context.Compilation, eventComponentType, classCandidates, OnRemovedEventViewAttributeType);
        var hasRemovedEventViewTypes = removedEventViewTypes.Count > 0;

        var ifDirty = classCandidates.Any(viewType =>
        {
            var viewTypeSymbol = (ITypeSymbol)context.Compilation.GetSemanticModel(viewType.SyntaxTree).GetDeclaredSymbol(viewType);
            foreach (var a in viewTypeSymbol.GetCustomAttributes(true))
            {
                if (a.IsAttribute(OnDirtyEventViewAttributeType))
                {
                    if (a.GetFieldValueTypes("Types").Contains(eventComponentType))
                    {
                        return true;
                    }
                }
            }

            return false;
        });

        if (ifDirty)
        {
            GenerateEventSystemOnDirtyEvents(dirtyEventViewTypes, eventComponentType, classModel, onCreateMethodModel, onUpdateMethodModel);
            GenerateEventSystemOnDirtyEventJobs(eventComponentType, classModel);
            GenerateEventSystemDirtyResetJobs(eventComponentType, classModel);
        }

        var ifAdd = classCandidates.Any(viewType =>
        {
            var viewTypeSymbol = (ITypeSymbol)context.Compilation.GetSemanticModel(viewType.SyntaxTree).GetDeclaredSymbol(viewType);
            foreach (var a in viewTypeSymbol.GetCustomAttributes(true))
            {
                if (a.IsAttribute(OnAddedEventViewAttributeType))
                {
                    if (a.GetFieldValueTypes("Types").Contains(eventComponentType))
                    {
                        return true;
                    }
                }
            }

            return false;
        });

        if (ifAdd)
        {
            GenerateEventSystemOnAddedEvents(addedEventViewTypes, eventComponentType, classModel, onCreateMethodModel, onUpdateMethodModel);
            GenerateEventSystemOnAddedEventJobs(eventComponentType, classModel);
        }

        var ifRemove = classCandidates.Any(viewType =>
        {
            var viewTypeSymbol = (ITypeSymbol)context.Compilation.GetSemanticModel(viewType.SyntaxTree).GetDeclaredSymbol(viewType);
            foreach (var a in viewTypeSymbol.GetCustomAttributes(true))
            {
                if (a.IsAttribute(OnRemovedEventViewAttributeType))
                {
                    if (a.GetFieldValueTypes("Types").Contains(eventComponentType))
                    {
                        return true;
                    }
                }
            }

            return false;
        });

        if (ifRemove)
        {
            GenerateEventSystemOnRemovedEvents(removedEventViewTypes, eventComponentType, classModel, onCreateMethodModel, onUpdateMethodModel);
            GenerateEventSystemOnRemovedEventJobs(eventComponentType, classModel);
        }

        if (!ifDirty && !ifAdd && !ifRemove)
        {
            return null;
        }

        return classModel;
    }

    private static void GenerateEventSystemOnAddedEvents(IEnumerable<ITypeSymbol> onAddedEventViewTypes, ITypeSymbol eventComponentType,
        ClassModel classModel, Method onCreateMethodModel, Method onUpdateMethodModel)
    {            
        foreach (var eventViewType in onAddedEventViewTypes)
        {
            classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery") {AccessModifier = AccessModifier.Private});
        }
            
        classModel.Fields.Add(new Field($"ComponentTypeHandle<AddedComponentArrayData>", $"_addedComponentArrayDataROComponentTypeHandle")
        {
            AccessModifier = AccessModifier.Private,
            Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
        });

        foreach (var eventViewType in onAddedEventViewTypes)
        {
            onCreateMethodModel.BodyLines.AddRange(new []
            {
                $"_entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery = GetEntityQuery(new EntityQueryDesc",
                "{",
                $"    All = new []",
                "    {",
                $"        ComponentType.ReadWrite<{eventViewType.ToDisplayString()}>(),",
                $"        ComponentType.ReadOnly<AddedComponentArrayData>(),",
                "    }",
                "});"
            });
        }

        onCreateMethodModel.BodyLines.AddRange(new[]
        {
            "_addedComponentArrayDataROComponentTypeHandle = GetComponentTypeHandle<AddedComponentArrayData>(true);",
            ""
        });               
            
        foreach (var eventViewType in onAddedEventViewTypes)
        {
            onUpdateMethodModel.BodyLines.AddRange(new []
            {
                "_addedComponentArrayDataROComponentTypeHandle.Update(this);",
                $"var notify{eventViewType.Name}Add{eventComponentType.Name}Job = new NotifyAdd{eventComponentType.Name}Job<{eventViewType.ToDisplayString()}>",
                "{",
                "    EntityManager = this.EntityManager,",
                $"    DataTypeHandle = _addedComponentArrayDataROComponentTypeHandle,",
                $"    ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.ToDisplayString()}>(false),",
                "};",
                "CompleteDependency();",
                $"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}Add{eventComponentType.Name}Job, _entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery);",
                ""
            });
        }
    }
        
    private static void GenerateEventSystemOnRemovedEvents(IEnumerable<ITypeSymbol> onRemovedEventViewTypes, ITypeSymbol eventComponentType,
        ClassModel classModel, Method onCreateMethodModel, Method onUpdateMethodModel)
    {            
        foreach (var eventViewType in onRemovedEventViewTypes)
        {
            classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery") {AccessModifier = AccessModifier.Private});
        }
            
        classModel.Fields.Add(new Field($"ComponentTypeHandle<RemovedComponentArrayData>", $"_removedComponentArrayDataROComponentTypeHandle")
        {
            AccessModifier = AccessModifier.Private,
            Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
        });

        foreach (var eventViewType in onRemovedEventViewTypes)
        {
            onCreateMethodModel.BodyLines.AddRange(new []
            {
                $"_entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery = GetEntityQuery(new EntityQueryDesc",
                "{",
                $"    All = new []",
                "    {",
                $"        ComponentType.ReadWrite<{eventViewType.ToDisplayString()}>(),",
                $"        ComponentType.ReadOnly<RemovedComponentArrayData>(),",
                "    }",
                "});"
            });
        }

        onCreateMethodModel.BodyLines.AddRange(new[]
        {
            "_removedComponentArrayDataROComponentTypeHandle = GetComponentTypeHandle<RemovedComponentArrayData>(true);",
            ""
        });               
            
        foreach (var eventViewType in onRemovedEventViewTypes)
        {
            onUpdateMethodModel.BodyLines.AddRange(new []
            {
                "_removedComponentArrayDataROComponentTypeHandle.Update(this);",
                $"var notify{eventViewType.Name}Remove{eventComponentType.Name}Job = new NotifyRemove{eventComponentType.Name}Job<{eventViewType.ToDisplayString()}>",
                "{",
                "    EntityManager = this.EntityManager,",
                $"    DataTypeHandle = _removedComponentArrayDataROComponentTypeHandle,",
                $"    ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.ToDisplayString()}>(false),",
                "};",
                "CompleteDependency();",
                $"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}Remove{eventComponentType.Name}Job, _entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery);",
                ""
            });
        }
    }
        
    private static void GenerateEventSystemOnDirtyEvents(IEnumerable<ITypeSymbol> dirtyEventViewTypes, ITypeSymbol eventComponentType,
        ClassModel classModel, Method onCreateMethodModel, Method onUpdateMethodModel)
    {            
        var eventComponentNameCamel = eventComponentType.Name.ToCamel();
        foreach (var eventViewType in dirtyEventViewTypes)
        {
            classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventViewType.Name}And{eventComponentType.Name}Query") {AccessModifier = AccessModifier.Private});
        }
            
        classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventComponentType.Name}Query") {AccessModifier = AccessModifier.Private});
        classModel.Fields.Add(new Field($"ComponentTypeHandle<{eventComponentType.Name}>", $"_{eventComponentNameCamel}ROComponentTypeHandle")
        {
            AccessModifier = AccessModifier.Private,
            Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
        });
        classModel.Fields.Add(new Field($"ComponentTypeHandle<{eventComponentType.Name}>", $"_{eventComponentNameCamel}RWComponentTypeHandle") {AccessModifier = AccessModifier.Private});

        foreach (var eventViewType in dirtyEventViewTypes)
        {
            onCreateMethodModel.BodyLines.AddRange(new []
            {
                $"_entityWith{eventViewType.Name}And{eventComponentType.Name}Query = GetEntityQuery(new EntityQueryDesc",
                "{",
                $"    All = new []",
                "    {",
                $"        ComponentType.ReadWrite<{eventViewType.ToDisplayString()}>(),",
                $"        ComponentType.ReadOnly<{eventComponentType.Name}>(),",
                "    }",
                "});",
                $"_entityWith{eventViewType.Name}And{eventComponentType.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{eventComponentType.Name}>());",
                ""
            });
        }
            
        onCreateMethodModel.BodyLines.AddRange(new []
        {
            $"_entityWith{eventComponentType.Name}Query = GetEntityQuery(new EntityQueryDesc",
            "{",
            $"    All = new []",
            "    {",
            $"        ComponentType.ReadWrite<{eventComponentType.Name}>(),",
            "    },",
            $"    Any = new []",
            "    {",
        });
        foreach (var eventViewType in dirtyEventViewTypes)
        {
            onCreateMethodModel.BodyLines.Add(
            $"        ComponentType.ReadOnly<{eventViewType.ToDisplayString()}>(),");
        }
        onCreateMethodModel.BodyLines.AddRange(new []
        {
            "    },",
            "});",
            $"_entityWith{eventComponentType.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{eventComponentType.Name}>());",
            ""
        });
            
        onCreateMethodModel.BodyLines.AddRange(new []
        {
            $"_{eventComponentNameCamel}ROComponentTypeHandle = GetComponentTypeHandle<{eventComponentType.Name}>(true);",
            $"_{eventComponentNameCamel}RWComponentTypeHandle = GetComponentTypeHandle<{eventComponentType.Name}>(false);",
            ""
        });
            
        foreach (var eventViewType in dirtyEventViewTypes)
        {
            onUpdateMethodModel.BodyLines.AddRange(new []
            {
                $"_{eventComponentNameCamel}ROComponentTypeHandle.Update(this);",
                $"var notify{eventViewType.Name}{eventComponentType.Name}DirtyJob = new Notify{eventComponentType.Name}DirtyJob<{eventViewType.ToDisplayString()}>",
                "{",
                "    EntityManager = this.EntityManager,",
                $"    DataTypeHandle = _{eventComponentNameCamel}ROComponentTypeHandle,",
                $"    ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.ToDisplayString()}>(false),",
                "};",
                "CompleteDependency();",
                $"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}{eventComponentType.Name}DirtyJob, _entityWith{eventViewType.Name}And{eventComponentType.Name}Query);",
                ""
            });
        }
            
        onUpdateMethodModel.BodyLines.AddRange(new []
        {
            $"_{eventComponentNameCamel}RWComponentTypeHandle.Update(this);",
            $"var {eventComponentNameCamel}ResetDirtyJob = new {eventComponentType.Name}ResetDirtyJob",
            "{",
            $"    DataTypeHandle = _{eventComponentNameCamel}RWComponentTypeHandle",
            "};",
            "CompleteDependency();",
            $"JobEntityBatchExtensions.RunWithoutJobs(ref {eventComponentNameCamel}ResetDirtyJob, _entityWith{eventComponentType.Name}Query);",
            ""
        });
    }

    private static List<ITypeSymbol> GetDirtyTypes(Compilation compilation, ITypeSymbol typeSymbol, IEnumerable<TypeDeclarationSyntax> classCandidates, string SearchAttributeName)
    {        
        return classCandidates.Where(eventType =>
        {
            var onDirtyEventViewAttribute = eventType.AttributeLists.FindAttribute(SearchAttributeName);
            var model = compilation.GetSemanticModel(eventType.SyntaxTree);
            var dirtyViewTypes = ExtractTypesFromAttribute(onDirtyEventViewAttribute, model);
            return dirtyViewTypes.Contains(typeSymbol);
        }).Select(eventType =>
        {
            var model = compilation.GetSemanticModel(eventType.SyntaxTree);
            ITypeSymbol eventTypeSymbol = (ITypeSymbol)model.GetDeclaredSymbol(eventType);
            return eventTypeSymbol;
        }).ToList();
    }

    private static void GenerateEventSystemOnDirtyEventJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var parametersToPassInOnChangedListener = "";
        var modelsFromFields = eventComponentType.GetFields().Select(field => new EventComponentFieldModel(field));
        var modelsFromProperties = eventComponentType.GetProperties().Select(property => new EventComponentFieldModel(property));
        IEnumerable<EventComponentFieldModel> fieldInfos = modelsFromFields.Union(modelsFromProperties).ToList();
        foreach (var fieldInfo in fieldInfos)
        {
            if (fieldInfo.HasMarkDirtyAttribute)
            {
                parametersToPassInOnChangedListener += $"data.{fieldInfo.Name}, ";
            }
        }

        parametersToPassInOnChangedListener = parametersToPassInOnChangedListener.Remove(parametersToPassInOnChangedListener.Length - 2, 2);            
        var eventComponentViewDirtyJobStruct = new StructModel($"Notify{eventComponentType.Name}DirtyJob<T>")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch where T : class, {GetDirtyInterfaceForEventComponentOfType(eventComponentType)}"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "EntityManager",
                    Name = "EntityManager",
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<{eventComponentType.Name}>",
                    Name = "DataTypeHandle",
                    Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "ComponentTypeHandle<T>",
                    Name = "ListenerTypeHandle"
                }
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        "var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);",
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                    
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    var listener = listenerAccessor[i];", 
                        "    if (data.IsDirty && listener != null)",
                        "    {",
                        $"        listener.On{GetNameRootFromEventComponentType(eventComponentType)}Changed({parametersToPassInOnChangedListener});",
                        "    }",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewDirtyJobStruct);
    }
        
    private static void GenerateEventSystemOnAddedEventJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var eventComponentViewDirtyJobStruct = new StructModel($"NotifyAdd{eventComponentType.Name}Job<T>")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch where T : class, {GetAddedInterfaceForEventComponentOfType(eventComponentType)}"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "EntityManager",
                    Name = "EntityManager",
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<AddedComponentArrayData>",
                    Name = "DataTypeHandle",
                    Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "ComponentTypeHandle<T>",
                    Name = "ListenerTypeHandle"
                }
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        "var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);",
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                    
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    var listener = listenerAccessor[i];", 
                        "    for (int j = 0; j < data.Value.Length; j++)",
                        "    {",
                        $"        if (data.Value[j] == ComponentType.ReadWrite<{eventComponentType.Name}>().TypeIndex)",
                        "        {",
                        $"            listener.On{GetNameRootFromEventComponentType(eventComponentType)}Added();",
                        "        }",
                        "    }",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewDirtyJobStruct);
    }

    private static void GenerateEventSystemOnRemovedEventJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var eventComponentViewDirtyJobStruct = new StructModel($"NotifyRemove{eventComponentType.Name}Job<T>")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch where T : class, {GetRemovedInterfaceForEventComponentOfType(eventComponentType)}"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "EntityManager",
                    Name = "EntityManager",
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<RemovedComponentArrayData>",
                    Name = "DataTypeHandle",
                    Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "ComponentTypeHandle<T>",
                    Name = "ListenerTypeHandle"
                }
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        "var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);",
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                    
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    var listener = listenerAccessor[i];", 
                        "    for (int j = 0; j < data.Value.Length; j++)",
                        "    {",
                        $"        if (data.Value[j] == ComponentType.ReadWrite<{eventComponentType.Name}>().TypeIndex)",
                        "        {",
                        $"            listener.On{GetNameRootFromEventComponentType(eventComponentType)}Removed();",
                        "        }",
                        "    }",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewDirtyJobStruct);
    }         
         
    private static void GenerateEventSystemDirtyResetJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var eventComponentViewCallbackJobStruct = new StructModel($"{eventComponentType.Name}ResetDirtyJob")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<{eventComponentType.Name}>",
                    Name = $"DataTypeHandle",
                },
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                            
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    if (data.IsDirty)",
                        "    {",
                        $"        data.IsDirty = false;",
                        "    }",
                        "    dataArray[i] = data;",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewCallbackJobStruct);
    }

    private static void GenerateEventViewInterfaceFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentWithEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateEventViewInterfaceImplementation(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateEventViewInterfaceImplementation(ITypeSymbol classWithEventsAttr)
    {
        var file = new FileModel($"{classWithEventsAttr.Name}Event")
        {
            Header = FileHeader,
            Namespace = classWithEventsAttr.ContainingNamespace.GetNamespace(),
        };

        var classModel = new ClassModel(classWithEventsAttr.Name)
        {
            AccessModifier = AccessModifier.Public,
            SingleKeyWord = KeyWord.Partial,
            Interfaces = new List<string>()
        };

        //for each ComponentData that is listened by ViewClass's OnAddedEventView attribute, implement its respective interface in the ViewClass
        var addedEventViewAttr = classWithEventsAttr.GetCustomAttribute(OnAddedEventViewAttributeType);
        if (addedEventViewAttr != null)
        {
            var addedEventTargetedEcsTypes = addedEventViewAttr.GetFieldValueTypes("Types");
            foreach (var addedEventTargetedEcsType in addedEventTargetedEcsTypes)
            {
                classModel.Interfaces.Add(GetAddedInterfaceForEventComponentOfType(addedEventTargetedEcsType));
            }
        }

        //for each ComponentData that is listened by ViewClass's OnRemovedEventView attribute, implement its respective interface in the ViewClass
        var removedEventViewAttr = classWithEventsAttr.GetCustomAttribute(OnRemovedEventViewAttributeType);
        if (removedEventViewAttr != null)
        {
            var removedEventTargetedEcsTypes = removedEventViewAttr.GetFieldValueTypes("Types");
            foreach (var removedEventTargetedEcsType in removedEventTargetedEcsTypes)
            {
                classModel.Interfaces.Add(GetRemovedInterfaceForEventComponentOfType(removedEventTargetedEcsType));
            }
        }

        //for each ComponentData that is listened by ViewClass's OnDirtyEventView attribute, implement its respective interface in the ViewClass
        var dirtyEventViewAttr = classWithEventsAttr.GetCustomAttribute(OnDirtyEventViewAttributeType);
        if (dirtyEventViewAttr != null)
        {
            foreach (var dirtyEventTargetedEcsType in dirtyEventViewAttr.GetFieldValueTypes("Types"))
            {
                classModel.Interfaces.Add(GetDirtyInterfaceForEventComponentOfType(dirtyEventTargetedEcsType));
            }
        }

        file.Classes.Add(classModel);
        return file;
    }

    private static void GenerateReadWriteEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ReadWriteEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateReadWriteEcs(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateReadWriteEcs(ITypeSymbol classWithWriteToEcs)
    {
        var file = new FileModel($"{classWithWriteToEcs.Name}ReadWrite")
        {
            Header = FileHeader,
            Namespace = classWithWriteToEcs.ContainingNamespace.GetNamespace(),
        };

        var classModel = new ClassModel(classWithWriteToEcs.Name);
        classModel.AccessModifier = AccessModifier.Public;
        classModel.SingleKeyWord = KeyWord.Partial;

        classModel.Properties = new List<Property>();

        var wteAttribute = classWithWriteToEcs.GetCustomAttribute(ReadWriteEcsAttributeType, true);
        foreach (var toWriteToType in wteAttribute.GetFieldValueTypes("Types"))
        {
            var propertyModel = new Property(toWriteToType.ToDisplayString(), toWriteToType.Name)
            {
                AccessModifier = AccessModifier.Public,
                IsExpressBody = true,
                IsAutoImplemented = false,
                GetterBody = $"EntityManager.GetComponentData<{toWriteToType.ToDisplayString()}>(LinkedEntity)",
                SetterBody = "EntityManager.SetComponentData(LinkedEntity, value)"
            };
            classModel.Properties.Add(propertyModel);
        }

        file.Classes.Add(classModel);
        return file;
    }

    private static void GenerateHasComponentEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.HasComponentEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateHasComponentEcs(typeSymbol);

            context.AddSource(typeSymbol.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateHasComponentEcs(ITypeSymbol classWithHasComponentEcs)
    {
        var file = new FileModel($"{classWithHasComponentEcs.Name}HasComponent")
        {
            Header = FileHeader,
            Namespace = classWithHasComponentEcs.ContainingNamespace.GetNamespace(),
        };

        var classModel = new ClassModel(classWithHasComponentEcs.Name)
        {
            AccessModifier = AccessModifier.Public,
            SingleKeyWord = KeyWord.Partial,
            Properties = new List<Property>()
        };

        var hasCpAttribute = classWithHasComponentEcs.GetCustomAttribute(HasComponentEcsAttributeType, true);
        foreach (var hasCpTypes in hasCpAttribute.GetFieldValueTypes("Types"))
        {
            var propertyModel = new Property("bool", $"Has{hasCpTypes.Name}")
            {
                AccessModifier = AccessModifier.Public,
                IsExpressBody = true,
                IsAutoImplemented = false,
                GetterBody = $"EntityManager.HasComponent<{hasCpTypes.ToDisplayString()}>(LinkedEntity)",
            };
            classModel.Properties.Add(propertyModel);
        }

        file.Classes.Add(classModel);
        return file;
    }

    private static void GenerateNetMessageFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.NetworkMessageTypes)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateNetMessage(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateNetMessage(ITypeSymbol netMessageType)
    {
        var file = new FileModel(netMessageType.Name + "Gen")
        {
            UsingDirectives = new List<string>
            {
                "DOTSNET;",
                "Unity.Collections;",
                "System;"
            },
            Header = FileHeader,
            Namespace = netMessageType.ContainingNamespace.GetNamespace(),
            Structs = new List<StructModel>()
        };

        var netMessageStructModel = new StructModel(netMessageType.Name)
        {
            AccessModifier = AccessModifier.Public,
            SingleKeyWord = KeyWord.Partial,
            Interfaces = new List<string> { "NetworkMessage" },
            Constructors = new List<Constructor>()
        };

        var modelsFromFields = netMessageType.GetFields().Where(f => f.DeclaredAccessibility != Accessibility.Private).Select(field => new EventComponentFieldModel(field));
        var modelsFromProperties = netMessageType.GetProperties().Where(f => f.DeclaredAccessibility != Accessibility.Private).Select(property => new EventComponentFieldModel(property));
        var fields = modelsFromFields.Union(modelsFromProperties).ToArray();
        var netMessageConstructor = new Constructor(netMessageType.Name)
        {
            AccessModifier = AccessModifier.Public,
            Parameters = fields.Select(f => new Parameter(f.Type.Name, f.Name.ToCamel())).ToList(),
            BodyLines = fields.Select(f => $"this.{f.Name} = {f.Name.ToCamel()};").ToList()
        };
        if (fields.Length > 0)
        {
            netMessageStructModel.Constructors.Add(netMessageConstructor);
        }

        // SerializeModel
        var netMessageSerializeMethodModel = new Method(BuiltInDataType.Bool, "Serialize")
        {
            AccessModifier = AccessModifier.Public,
            Parameters = new List<Parameter> { new Parameter("ref NetworkWriter writer") },
            BodyLines = new List<string>()
        };

        var totalFieldsCount = fields.Length;
        if (totalFieldsCount == 0)
        {
            netMessageSerializeMethodModel.BodyLines.Add("return true;");
        }
        else
        {
            netMessageSerializeMethodModel.BodyLines.Add("return");

            for (var i = 0; i < totalFieldsCount; i++)
            {
                var fieldInfo = fields[i];
                if (!IsDotsnetCompatibleType(fieldInfo.Type))
                {
                    throw new Exception($"Failed to find {fieldInfo.Type.Name}");
                }

                var conversion = IsDotsnetType(fieldInfo.Type) ? string.Empty : $"({GetDotsnetCompatibleType(fieldInfo.Type).ToDisplayString()})";
                var baseMessage = $"writer.Write{GetDotsnetTypeName(fieldInfo.Type)}({conversion}{fieldInfo.Name})";
                if (i == totalFieldsCount - 1)
                {
                    //last one
                    netMessageSerializeMethodModel.BodyLines.Add($"{baseMessage};");
                }
                else
                {
                    netMessageSerializeMethodModel.BodyLines.Add(
                        $"{baseMessage} &&");
                }

            }
        }

        netMessageStructModel.Methods.Add(netMessageSerializeMethodModel);

        // DeserializeModel
        var netMessageDeserializeMethodModel = new Method(BuiltInDataType.Bool, "Deserialize")
        {
            AccessModifier = AccessModifier.Public,
            Parameters = new List<Parameter> { new Parameter("ref NetworkReader reader") },
            BodyLines = new List<string>()
        };

        totalFieldsCount = fields.Length;
        if (totalFieldsCount == 0)
        {
            netMessageDeserializeMethodModel.BodyLines.Add("return true;");
        }
        else
        {
            foreach (var fieldInfo in fields)
            {
                var type = GetDotsnetCompatibleType(fieldInfo.Type);
                netMessageDeserializeMethodModel.BodyLines.Add($"{type} {fieldInfo.Name.ToCamel()} = default;");
            }
                
            netMessageDeserializeMethodModel.BodyLines.Add("var result =");

            for (var i = 0; i < totalFieldsCount; i++)
            {
                var fieldInfo = fields[i];
                if (!IsDotsnetCompatibleType(fieldInfo.Type))
                {
                    throw new Exception($"Failed to find {fieldInfo.Type.Name}");
                }

                var baseMessage = $"reader.Read{GetDotsnetTypeName(fieldInfo.Type)}(out {fieldInfo.Name.ToCamel()})";
                if (i == totalFieldsCount - 1)
                {
                    // last one
                    netMessageDeserializeMethodModel.BodyLines.Add($"{baseMessage};");
                }
                else
                {
                    netMessageDeserializeMethodModel.BodyLines.Add($"{baseMessage} &&");
                }

            }
            netMessageDeserializeMethodModel.BodyLines.Add("if (!result) return false;");
            foreach (var fieldInfo in fields)
            {
                var conversion = IsDotsnetType(fieldInfo.Type) ? string.Empty : $"({fieldInfo.Type.ToDisplayString()})";
                netMessageDeserializeMethodModel.BodyLines.Add($"this.{fieldInfo.Name} = {conversion}{fieldInfo.Name.ToCamel()};");
            }

            netMessageDeserializeMethodModel.BodyLines.Add("return true;");
        }

        netMessageStructModel.Methods.Add(netMessageDeserializeMethodModel);

        file.Structs.Add(netMessageStructModel);
        return file;
    }

    private static void GenerateNetworkComponentFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            if (!typeSymbol.HasAttribute(CodeGenNetComponentAttributeType))
            {
                continue;
            }

            var file = GenerateNetworkComponent(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateNetworkComponent(ITypeSymbol eventComponentDataType)
    {
        var file = new FileModel(eventComponentDataType.Name + "Serializer")
        {
            UsingDirectives = new List<string>
            {
                "Unity.Jobs;"
            },
            Header = FileHeader,
            Namespace = eventComponentDataType.ContainingNamespace.GetNamespace(),
        };

        var serializerClass = GenerateNetworkComponentSerializerClassModel(eventComponentDataType);
        file.Classes.Add(serializerClass);
        file.Attributes.AddRange(serializerClass.Attributes);
        serializerClass.Attributes.Clear();
        return file;
    }

    private static ClassModel GenerateNetworkComponentSerializerClassModel(ITypeSymbol eventComponentDataType)
    {
        var networkComponentSerializerClassModel = new ClassModel($"{eventComponentDataType.Name}Serializer")
        {
            BaseClass = $"DOTSNetworkComponentSerializer<{eventComponentDataType.ToDisplayString()}>",
            AccessModifier = AccessModifier.Public,
            Attributes = new List<AttributeModel>
            {
                new($"assembly: RegisterGenericJobType(typeof(DOTSNetworkComponentSerializer<{eventComponentDataType.ToDisplayString()}>.NetworkComponentSerializerJob))"),
                new($"assembly: RegisterGenericJobType(typeof(DOTSNetworkComponentSerializer<{eventComponentDataType.ToDisplayString()}>.NetworkComponentDeserializerJob))")
            }
        };

        return networkComponentSerializerClassModel;
    }

    private static IEnumerable<ITypeSymbol> ExtractTypesFromAttribute(AttributeSyntax attributeSyntax, SemanticModel model)
    {
        if (attributeSyntax == null || attributeSyntax.ArgumentList == null)
        {
            return Array.Empty<ITypeSymbol>();
        }

        var typeOfExpressions = attributeSyntax.ArgumentList.Arguments.Select(_ => _.Expression).OfType<TypeOfExpressionSyntax>();
        var validTypes = typeOfExpressions.Select(typeOfExpression => model.GetTypeInfo(typeOfExpression.Type)).Where(_ => _.Type != null).Select(_ => _.Type!);
        return validTypes;
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    /// <summary>
    /// Helper to get the name of the DirtyEvent interface for certain ComponentData, used for partial ViewClass generation
    /// </summary>
    /// <param name="eventComponentType">Component type for which get name of corresponding change listener.</param>
    /// <returns>Name of the change listener interface for the component.</returns>
    private static string GetDirtyInterfaceForEventComponentOfType(ITypeSymbol eventComponentType)
    {
        var baseName = $"I{GetNameRootFromEventComponentType(eventComponentType)}Listener";
        if (eventComponentType.ContainingNamespace == null || eventComponentType.ContainingNamespace.IsGlobalNamespace)
        {
            return baseName;
        }

        return $"{eventComponentType.ContainingNamespace.GetNamespace()}.{baseName}";
    }

    /// <summary>
    /// Helper to get the name of the AddedEvent interface for certain ComponentData, used for partial ViewClass generation
    /// </summary>
    /// <param name="eventComponentType">Component type for which get name of corresponding add listener.</param>
    /// <returns>Name of the add listener interface for the component.</returns>
    private static string GetAddedInterfaceForEventComponentOfType(ITypeSymbol eventComponentType)
    {
        var baseName = $"I{GetNameRootFromEventComponentType(eventComponentType)}AddedListener";
        if (eventComponentType.ContainingNamespace == null || eventComponentType.ContainingNamespace.IsGlobalNamespace)
        {
            return baseName;
        }

        return $"{eventComponentType.ContainingNamespace.GetNamespace()}.{baseName}";
    }

    /// <summary>
    /// Helper to get the name of the RemovedEvent interface for certain ComponentData
    /// </summary>
    /// <param name="eventComponentType">Component type for which get name of corresponding remove listener.</param>
    /// <returns>Name of the remove listener interface for the component.</returns>
    private static string GetRemovedInterfaceForEventComponentOfType(ITypeSymbol eventComponentType)
    {
        var baseName = $"I{GetNameRootFromEventComponentType(eventComponentType)}RemovedListener";
        if (eventComponentType.ContainingNamespace == null || eventComponentType.ContainingNamespace.IsGlobalNamespace)
        {
            return baseName;
        }

        return $"{eventComponentType.ContainingNamespace.GetNamespace()}.{baseName}";
    }

    /// <summary>
    /// ComponentData struct usually suffix with Tag or Data indicating what they are used for.
    /// In order to generate related system or partial structs, those suffix are stripped in order to get the name of the ComponentData struct.
    /// </summary>
    /// <param name="eventComponentType"></param>
    /// <returns></returns>
    private static string GetNameRootFromEventComponentType(ITypeSymbol eventComponentType)
    {
        var typeName = eventComponentType.Name;
        if (typeName.EndsWith("Tag"))
        {
            return typeName.Substring(0, typeName.Length - 3);
        }
        else if (typeName.EndsWith("Data"))
        {
            return typeName.Substring(0, typeName.Length - 4);
        }
        else
        {
            return typeName;
        }
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<StructDeclarationSyntax> ComponentDirtyEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ComponentWithEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ReadWriteEcs { get; } = new();
        public List<ClassDeclarationSyntax> HasComponentEcs { get; } = new();
        public List<StructDeclarationSyntax> NetworkMessageTypes { get; } = new();
        public List<ClassDeclarationSyntax> SelectiveSystems { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context is StructDeclarationSyntax structDeclarationSyntax
                && structDeclarationSyntax.AttributeLists.Count > 0)
            {
                var componentDirtyEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentDirtyEventAttributeType);
                var componentRemovedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentRemovedEventAttributeType);
                var componentAddedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentAddedEventAttributeType);
                var codeGenNetComponentAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(CodeGenNetComponentAttributeType);
                if (componentDirtyEventAttribute != null || codeGenNetComponentAttribute != null
                    || componentRemovedEventAttribute != null || componentAddedEventAttribute != null)
                {
                    this.ComponentDirtyEventStructs.Add(structDeclarationSyntax);
                }

                var codeGenNetMessageAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(CodeGenNetMessageAttributeType);
                if (codeGenNetMessageAttribute != null)
                {
                    this.NetworkMessageTypes.Add(structDeclarationSyntax);
                }
            }

            if (context is ClassDeclarationSyntax classtDeclarationSyntax
                && classtDeclarationSyntax.AttributeLists.Count > 0)
            {
                var onAddedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute(OnAddedEventViewAttributeType);
                var onRemovedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute(OnRemovedEventViewAttributeType);
                var onDirtyEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute(OnDirtyEventViewAttributeType);
                if (onAddedEventViewAttribute != null || onRemovedEventViewAttribute != null || onDirtyEventViewAttribute != null)
                {
                    this.ComponentWithEventStructs.Add(classtDeclarationSyntax);
                }

                var readWriteEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("ReadWriteEcs");
                if (readWriteEcsAttribute != null)
                {
                    this.ReadWriteEcs.Add(classtDeclarationSyntax);
                }

                var hasComponentEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("HasComponentEcs");
                if (hasComponentEcsAttribute != null)
                {
                    this.HasComponentEcs.Add(classtDeclarationSyntax);
                }

                var hasSelectiveSystemAuthoring = classtDeclarationSyntax.AttributeLists.FindAttribute(GenerateSystemAuthoringAttributeType);
                if (hasSelectiveSystemAuthoring != null)
                {
                    this.SelectiveSystems.Add(classtDeclarationSyntax);
                }
            }
        }
    }
}
