using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using CsCodeGenerator;
using CsCodeGenerator.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace LittleToySourceGenerator;

[Generator]
public class Generator : ISourceGenerator
{
    public bool EnableEventDataGeneration { get; set; } = true;
    public bool GenerateEventSystem { get; set; } = true;
    public bool GenerateEventViewInterface { get; set; } = true;
    public bool GenerateReadWriteEcs { get; set; } = true;

    public const string ComponentDirtyEventAttributeType = "ComponentDirtyEvent";

    public const string CodeGenNetComponentAttributeType = "CodeGenNetComponent";

    public const string MarkDirtyAttributeType = "MarkDirty";

    public const string SyncFieldAttributeType = "SyncField";

    public const string ComponentRemovedEventAttributeType = "ComponentRemovedEvent";

    public const string ComponentAddedEventAttributeType = "ComponentAddedEvent";

    private const string FileHeader = @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591";

    private static DiagnosticDescriptor FieldTypeShouldBeKnownForDotsNet = new DiagnosticDescriptor(
        "LT0001",
        "Field type should be known to DOTSNET", 
        "Cannot convert field type {0} to dotsnet read/write methods",
        "LittleToy",
        DiagnosticSeverity.Error, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static DiagnosticDescriptor NetComponentShouldHaveSyncField = new DiagnosticDescriptor(
        "LT0002",
        "Net component should have SyncField",
        "Type {0} does not have any field marked with SyncFieldAttribute",
        "LittleToy",
        DiagnosticSeverity.Error, isEnabledByDefault: true, description: "Use only types known by DOTSNET");


    private static Dictionary<string, string> _systemToDotsnetTypeDictionary = new Dictionary<string, string>()
    {
        { "System.Byte", "Byte"},
        { "System.Boolean", "Bool"},
        { "System.Int16", "Short"},
        { "System.UInt16", "UShort"},
        { "System.Int32", "Int"},
        { "System.UInt32", "UInt"},
        { "Unity.Mathematics.int2", "Int2" },
        { "Unity.Mathematics.int3", "Int3" },
        { "Unity.Mathematics.int4", "Int4" },
        { "System.UInt64", "ULong" },
        { "System.Int64", "Long" },
        { "DOTSNET.long3", "Long3" },
        { "System.Single", "Float" },
        { "Unity.Mathematics.float2", "Float2" },
        { "Unity.Mathematics.float3", "Float3" },
        { "Unity.Mathematics.float4", "Float4" },
        { "System.Double", "Double"},
        { "Unity.Mathematics.double2", "Double2" },
        { "Unity.Mathematics.double3", "Double3" },
        { "Unity.Mathematics.double4", "Double4" },
        { "System.Decimal", "Decimal"},
        { "Unity.Mathematics.quaternion", "Quaternion"},
        { "Unity.Collections.FixedBytes16", "Bytes16"},
        { "Unity.Collections.FixedBytes30", "Bytes30"},
        { "Unity.Collections.FixedBytes62", "Bytes62"},
        { "Unity.Collections.FixedBytes126", "Bytes126"},
        { "Unity.Collections.FixedBytes510", "Bytes510"},
        { "Unity.Collections.FixedBytes4094", "Bytes4094"},
        { "Unity.Collections.FixedString32Bytes", "FixedString32"},
        { "Unity.Collections.FixedString64Bytes", "FixedString64"},
        { "Unity.Collections.FixedString128Bytes", "FixedString128"},
        { "Unity.Collections.FixedString512Bytes", "FixedString512"}
    };

    public void DisableAllGeneration()
    {
        EnableEventDataGeneration = false;
        GenerateEventSystem = false;
        GenerateEventViewInterface = false;
        GenerateReadWriteEcs = false;
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        if (EnableEventDataGeneration)
        {
            GenerateEventDataFiles(context, receiver);
        }

        if (GenerateEventSystem)
        {
            GenerateEventSystemFiles(context, receiver);
        }

        if (GenerateEventViewInterface)
        {
            GenerateEventViewInterfaceFiles(context, receiver);
        }

        if (GenerateReadWriteEcs)
        {
            GenerateReadWriteEcsFiles(context, receiver);
            GenerateHasComponentEcsFiles(context, receiver);
        }
    }

    private static void GenerateEventDataFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateEventData(typeSymbol, context, type);
            context.AddSource(typeSymbol.Name + "EventData", SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateEventData(ITypeSymbol eventComponentType, GeneratorExecutionContext context, SyntaxNode syntaxNode)
    {
        var file = new FileModel(eventComponentType.Name + "EventData")
        {
            UsingDirectives = new List<string>
            {
                "System;",
                "Unity.Entities;",
                "Unity.Mathematics;",
                "Plugins.basegame.Events;",
                "DOTSNET;",
                "Unity.Collections;"
            },
            Namespace = eventComponentType.ContainingNamespace?.Name ?? "",
            Header = FileHeader,
        };

        // Generate methods and properties used for dirty event of ComponentData
        if (eventComponentType.HasAttribute(ComponentDirtyEventAttributeType) || eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            // Create the StructModel used for code generation
            file.Structs.Add(GenerateEventStructModel(eventComponentType, context, syntaxNode));
        }

        // Generate listeners required for each type of event add/remove/dirty
        file.Interfaces.Add(GenerateComponentDirtyEventInterfaceModel(eventComponentType));
        file.Interfaces.Add(GenerateComponentRemovedEventInterfaceModel(eventComponentType));
        file.Interfaces.Add(GenerateComponentAddedEventInterface(eventComponentType));
        return file;
    }

    /// <summary>
    /// Generate the struct model used for code generation
    /// </summary>
    /// <param name="eventComponentType">Component type for which generate EventData structure implementation.</param>
    /// <param name="context">Code generation context in which generate the struct.</param>
    /// <param name="syntaxNode">Syntax node for which attempt to generate code happens.</param>
    /// <returns>A <see cref="StructModel"/> representing generated component.</returns>
    private static StructModel GenerateEventStructModel(ITypeSymbol eventComponentType, GeneratorExecutionContext context, SyntaxNode syntaxNode)
    {
        //Only generate IfDirty Property if there's any field marked with [MarkDirty] attribute
        var needIfDirty = false;
        foreach (var fieldInfo in eventComponentType.GetFields())
        {
            if (fieldInfo.HasAttribute(MarkDirtyAttributeType))
            {
                needIfDirty = true;
                break;
            }
        }

        var structModel = new StructModel(eventComponentType.Name)
        {
            SingleKeyWord = KeyWord.Partial,
            Properties = new List<Property>(),
            Interfaces = new List<string>()
        };

        if (needIfDirty)
        {
            structModel.Properties.Add(new Property(BuiltInDataType.Bool, "IsDirty")
            {
                AccessModifier = AccessModifier.Public
            });
        }

        // Implement NetworkComponent interface if has attribute CodeGenNetComponent
        if (eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            structModel.Interfaces.Add("NetworkComponent");
        }

        // Generate update method, when there's at least one field with MarkDirty and without SyncField attribute
        // the Update method used to update the fields/properties of the struct then mark the struct as dirty.
        List<IFieldSymbol> fieldsWithMarkDirtyAndWithoutSyncField = new List<IFieldSymbol>();
        foreach (var fieldInfo in eventComponentType.GetFields())
        {
            if (fieldInfo.HasAttribute(MarkDirtyAttributeType) &&
                fieldInfo.HasAttribute(SyncFieldAttributeType) == false)
            {
                fieldsWithMarkDirtyAndWithoutSyncField.Add(fieldInfo);
            }
        }

        if (fieldsWithMarkDirtyAndWithoutSyncField.Count > 0)
        {
            var method = new Method(BuiltInDataType.Void, "Update")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>(),
                BodyLines = new List<string>()
                {
                    "if(",
                    "",
                    "IsDirty = true;"
                },
                CustomDataType = eventComponentType.Name
            };

            var isFirst = true;

            // The body of the update method
            foreach (var fieldInfo in fieldsWithMarkDirtyAndWithoutSyncField)
            {
                method.Parameters.Add(new Parameter()
                {
                    CustomDataType = fieldInfo.Type.Name,
                    Name = fieldInfo.Name.LowerFirst()
                });

                if (!isFirst)
                    method.BodyLines[0] += " && ";

                method.BodyLines[0] += $"{fieldInfo.Name}.Equals({fieldInfo.Name.LowerFirst()})";
                isFirst = false;

                method.BodyLines.Add($"{fieldInfo.Name} = {fieldInfo.Name.LowerFirst()};");
            }

            method.BodyLines[0] += ") return this;";

            method.BodyLines.Add("");
            method.BodyLines.Add("return this;");

            structModel.Methods.Add(method);
        }

        if (eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            // Generate the GetSyncDirection Method
            var syncDir = eventComponentType.GetCustomAttribute(CodeGenNetComponentAttributeType).GetFieldValue("SyncDirection");
            var GetSyncDirectionMethodModel = new Method("SyncDirection", "GetSyncDirection")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>(),
                BodyLines = new List<string>()
                {
                    $"return SyncDirection.{syncDir.ToString()};"
                },
            };
            structModel.Methods.Add(GetSyncDirectionMethodModel);

            // Get syncField field list
            var fieldWithSyncFieldAttribute = new List<IFieldSymbol>();
            var fieldWithSyncFieldAndMarkDirtyAttribute = new List<IFieldSymbol>();

            foreach (var fieldInfo in eventComponentType.GetFields())
            {
                if (fieldInfo.HasAttribute(SyncFieldAttributeType))
                {
                    fieldWithSyncFieldAttribute.Add(fieldInfo);
                    if (fieldInfo.HasAttribute(MarkDirtyAttributeType))
                    {
                        fieldWithSyncFieldAndMarkDirtyAttribute.Add(fieldInfo);
                    }
                }
            }

            if (fieldWithSyncFieldAttribute.Count == 0)
            {
                var err = Diagnostic.Create(NetComponentShouldHaveSyncField, location: syntaxNode.GetLocation(), eventComponentType.Name);
                context.ReportDiagnostic(err);
            }

            var serializeMethodModel = new Method(BuiltInDataType.Bool, "Serialize")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>
                {
                    new Parameter("ref NetworkWriter128 writer")
                },
                BodyLines = new List<string>()
                {
                    "return"
                },
            };

            for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
            {
                var fieldInfo = fieldWithSyncFieldAttribute[i];
                var fieldType = fieldInfo.Type;

                if (IsDotsnetType(fieldType) == false)
                {
                    var err = Diagnostic.Create(FieldTypeShouldBeKnownForDotsNet, location: syntaxNode.GetLocation(), fieldType.Name);
                    context.ReportDiagnostic(err);
                    return structModel;
                }

                if (i == fieldWithSyncFieldAttribute.Count - 1)
                {
                    // last one
                    serializeMethodModel.BodyLines[0] += $" writer.Write{GetDotsnetTypeName(fieldType)}({fieldInfo.Name});";
                }
                else
                {
                    serializeMethodModel.BodyLines[0] += $" writer.Write{GetDotsnetTypeName(fieldType)}({fieldInfo.Name}) &&";
                }
            }

            structModel.Methods.Add(serializeMethodModel);

            var shouldDealWithDirtyInDeserialize = fieldWithSyncFieldAndMarkDirtyAttribute.Count > 0;
            var deserializeMethodModel = new Method(BuiltInDataType.Bool, "Deserialize")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter> { new Parameter("ref NetworkReader128 reader") },
            };

            if (shouldDealWithDirtyInDeserialize)
            {
                deserializeMethodModel.BodyLines = new List<string>()
                {
                    "if (",
                    "{",
                    "    if (",
                    "    {",
                    "        IsDirty = true;",
                };
            }
            else
            {
                deserializeMethodModel.BodyLines = new List<string>()
                {
                    "return"
                };
            }

            if (shouldDealWithDirtyInDeserialize)
            {
                for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
                {
                    var fieldInfo = fieldWithSyncFieldAttribute[i];
                    var fieldType = fieldInfo.Type;

                    if (IsDotsnetType(fieldType) == false)
                    {
                        var err = Diagnostic.Create(FieldTypeShouldBeKnownForDotsNet, location: syntaxNode.GetLocation(), fieldType.Name);
                        context.ReportDiagnostic(err);
                        return structModel;
                    }

                    if (i == 0)
                    {
                        if (fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo))
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $"reader.Read{GetDotsnetTypeName(fieldType)}(out var {fieldInfo.Name.ToLower()})";
                            deserializeMethodModel.BodyLines[2] +=
                                $"{fieldInfo.Name} != {fieldInfo.Name.ToLower()}";
                            deserializeMethodModel.BodyLines.Add(
                                $"        {fieldInfo.Name} = {fieldInfo.Name.ToLower()};");
                        }
                        else
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $"reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name})";
                        }
                    }
                    else
                    {
                        if (fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo))
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $" && reader.Read{GetDotsnetTypeName(fieldType)}(out var {fieldInfo.Name.ToLower()})";
                            deserializeMethodModel.BodyLines[2] +=
                                $" || {fieldInfo.Name} != {fieldInfo.Name.ToLower()}";
                            deserializeMethodModel.BodyLines.Add(
                                $"        {fieldInfo.Name} = {fieldInfo.Name.ToLower()};");
                        }
                        else
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $" && reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name})";
                        }
                    }
                }

                deserializeMethodModel.BodyLines[0] += ")";
                deserializeMethodModel.BodyLines[2] += ")";

                deserializeMethodModel.BodyLines.Add("    }");
                deserializeMethodModel.BodyLines.Add("    return true;");
                deserializeMethodModel.BodyLines.Add("}");
                deserializeMethodModel.BodyLines.Add("return false;");
            }
            else
            {
                for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
                {
                    var fieldInfo = fieldWithSyncFieldAttribute[i];
                    var fieldType = fieldInfo.Type;

                    if (IsDotsnetType(fieldType) == false)
                    {
                        var err = Diagnostic.Create(FieldTypeShouldBeKnownForDotsNet, location: syntaxNode.GetLocation(), fieldType.Name);
                        context.ReportDiagnostic(err);
                        return structModel;
                    }

                    if (i == fieldWithSyncFieldAttribute.Count - 1)
                    {
                        // last one
                        deserializeMethodModel.BodyLines[0] +=
                            $" reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name});";
                    }
                    else
                    {
                        deserializeMethodModel.BodyLines[0] +=
                            $" reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name}) &&";
                    }
                }
            }

            structModel.Methods.Add(deserializeMethodModel);
        }

        return structModel;
    }

    /// <summary>
    /// Generate listeners required for ComponentData dirty event, this is used in ViewClasses to receive events
    /// </summary>
    /// <param name="eventComponentType">Component type for which generate IXXXListener interface declaration.</param>
    /// <returns>An <see cref="InterfaceModel"/> for generated IXXXListener interface or null if interface would not be generated.</returns>
    private static InterfaceModel GenerateComponentDirtyEventInterfaceModel(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentDirtyEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);

        var interfaceModel = new InterfaceModel($"I{nameRoot}Listener")
        {
            AccessModifier = AccessModifier.Public
        };
        var method = new Method(BuiltInDataType.Void, $"On{nameRoot}Changed")
        {
            Parameters = new List<Parameter>(),
            WithoutBody = true
        };

        foreach (var fieldInfo in eventComponentType.GetFields())
        {
            if (fieldInfo.Name == "IsDirty" || fieldInfo.GetAttributes().All(attr => !attr.IsAttribute(MarkDirtyAttributeType)))
            {
                continue;
            }

            method.Parameters.Add(new Parameter()
            {
                CustomDataType = fieldInfo.Type.Name,
                Name = fieldInfo.Name.LowerFirst()
            });
        }

        interfaceModel.Methods.Add(method);
        return interfaceModel;
    }

    // Generate listeners required for ComponentData removed event, this is used in ViewClasses to receive events
    private static InterfaceModel GenerateComponentRemovedEventInterfaceModel(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentRemovedEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var interfaceModel = new InterfaceModel($"I{nameRoot}RemovedListener")
        {
            AccessModifier = AccessModifier.Public,
            Methods = new List<Method>
            {
                new Method(BuiltInDataType.Void, $"On{nameRoot}Removed")
                {
                    Parameters = new List<Parameter>(),
                    WithoutBody = true
                }
            }
        };

        return interfaceModel;
    }

    // Generate listeners required for ComponentData added event, this is used in ViewClasses to receive events
    private static InterfaceModel GenerateComponentAddedEventInterface(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentAddedEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var interfaceModel = new InterfaceModel($"I{nameRoot}AddedListener")
        {
            AccessModifier = AccessModifier.Public,
            Methods = new List<Method>
            {
                new Method(BuiltInDataType.Void, $"On{nameRoot}Added")
                {
                    Parameters = new List<Parameter>(),
                    WithoutBody = true
                }
            }
        };

        return interfaceModel;
    }

    private static string GetFullyQualifiedName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.SpecialType switch
        {
            SpecialType.System_Byte => "System.Byte",
            SpecialType.System_SByte => "System.SByte",
            SpecialType.System_Single => "System.Single",
            SpecialType.System_Double => "System.Double",
            SpecialType.System_Decimal => "System.Decimal",
            SpecialType.System_Int16 => "System.Int16",
            SpecialType.System_Int32 => "System.Int32",
            SpecialType.System_Int64 => "System.Int64",
            SpecialType.System_UInt16 => "System.UInt16",
            SpecialType.System_UInt32 => "System.UInt32",
            SpecialType.System_UInt64 => "System.UInt64",
            _ => typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
        };
    }

    private static bool IsDotsnetType(ITypeSymbol typeSymbol)
    {
        return _systemToDotsnetTypeDictionary.ContainsKey(GetFullyQualifiedName(typeSymbol));
    }

    private static string GetDotsnetTypeName(ITypeSymbol typeSymbol)
    {
        return _systemToDotsnetTypeDictionary[GetFullyQualifiedName(typeSymbol)];
    }

    private static void GenerateEventSystemFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            builder.AppendLine($"[UpdateBefore(typeof(CleanUpAddedRemovedEventSystem))]");
            builder.AppendLine($"[ClientWorld]");
            builder.AppendLine($"[UpdateInGroup(typeof(SimulationSystemGroup), OrderLast = true)]");
            builder.AppendLine($"public partial class {GetNameRootFromEventComponentType(typeSymbol)}EventSystem : SystemBase");
            builder.OpenBraces();

            List<ClassDeclarationSyntax> classCandidates = receiver.ComponentWithEventStructs;
            var dirtyEventViewTypes = GetDirtyTypes(context.Compilation, typeSymbol, classCandidates, "OnDirtyEventView");
            var hasDirtyEventViewTypes = dirtyEventViewTypes.Count > 0;
            var addedEventViewTypes = GetDirtyTypes(context.Compilation, typeSymbol, classCandidates, "OnAddedEventView");
            var hasAddedEventViewTypes = addedEventViewTypes.Count > 0;
            var removedEventViewTypes = GetDirtyTypes(context.Compilation, typeSymbol, classCandidates, "OnRemovedEventView");
            var hasRemovedEventViewTypes = removedEventViewTypes.Count > 0;

            // Fields
            if (hasDirtyEventViewTypes)
            {
                foreach (var eventViewType in dirtyEventViewTypes)
                {
                    builder.AppendLine($"private EntityQuery _entityWith{eventViewType.Name}And{typeSymbol.Name}Query;");
                }

                builder.AppendLine($"private EntityQuery _entityWith{typeSymbol.Name}Query;");
                builder.AppendLine($"private ComponentTypeHandle<{typeSymbol.Name}> _{typeSymbol.Name}ROComponentTypeHandle;");
                builder.AppendLine($"private ComponentTypeHandle<{typeSymbol.Name}> _{typeSymbol.Name}RWComponentTypeHandle;");
            }

            if (hasAddedEventViewTypes)
            {
                foreach (var eventViewType in addedEventViewTypes)
                {
                    builder.AppendLine($"private EntityQuery _entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery;");
                }

                builder.AppendLine($"private ComponentTypeHandle<AddedComponentArrayData> _addedComponentArrayDataROComponentTypeHandle;");
            }

            if (hasRemovedEventViewTypes)
            {
                foreach (var eventViewType in removedEventViewTypes)
                {
                    builder.AppendLine($"private EntityQuery _entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery;");
                }

                builder.AppendLine($"private ComponentTypeHandle<RemovedComponentArrayData> _removedComponentArrayDataROComponentTypeHandle;");
            }

            builder.AppendLine();

            // OnCreate
            builder.AppendLine($"protected override void OnCreate()");
            builder.OpenBraces();
            builder.AppendLine($"base.OnCreate();");
            if (hasDirtyEventViewTypes)
            {
                foreach (var eventViewType in dirtyEventViewTypes)
                {
                    builder.AppendLine($"_entityWith{eventViewType.Name}And{typeSymbol.Name}Query = GetEntityQuery(new EntityQueryDesc");
                    builder.OpenBraces();
                    builder.AppendLine($"All = new []");
                    builder.OpenBraces();
                    builder.AppendLine($"ComponentType.ReadWrite<{eventViewType.Name}>(),");
                    builder.AppendLine($"ComponentType.ReadOnly<{typeSymbol.Name}>(),");
                    builder.CloseBraces();
                    builder.CloseBraces(");");
                    builder.AppendLine($"_entityWith{eventViewType.Name}And{typeSymbol.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{typeSymbol.Name}>());");
                    builder.AppendLine();
                }

                builder.AppendLine($"_entityWith{typeSymbol.Name}Query = GetEntityQuery(new EntityQueryDesc");
                builder.OpenBraces();
                builder.AppendLine($"All = new []");
                builder.OpenBraces();
                builder.AppendLine($"ComponentType.ReadWrite<{typeSymbol.Name}>(),");
                builder.CloseBraces();
                builder.CloseBraces(");");
                builder.AppendLine($"_entityWith{typeSymbol.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{typeSymbol.Name}>());");
                builder.AppendLine($"_{typeSymbol.Name}ROComponentTypeHandle = GetComponentTypeHandle<{typeSymbol.Name}>(true);");
                builder.AppendLine($"_{typeSymbol.Name}RWComponentTypeHandle = GetComponentTypeHandle<{typeSymbol.Name}>(false);");
            }

            if (hasAddedEventViewTypes)
            {
                foreach (var eventViewType in addedEventViewTypes)
                {
                    builder.AppendLine($"_entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery = GetEntityQuery(new EntityQueryDesc");
                    builder.OpenBraces();
                    builder.AppendLine($"All = new []");
                    builder.OpenBraces();
                    builder.AppendLine($"ComponentType.ReadWrite<{eventViewType.Name}>(),");
                    builder.AppendLine($"ComponentType.ReadOnly<AddedComponentArrayData>(),");
                    builder.CloseBraces();
                    builder.CloseBraces(");");
                    builder.AppendLine();
                }

                builder.AppendLine($"_addedComponentArrayDataROComponentTypeHandle = GetComponentTypeHandle<AddedComponentArrayData>(true);");
            }

            if (hasRemovedEventViewTypes)
            {
                foreach (var eventViewType in removedEventViewTypes)
                {
                    builder.AppendLine($"_entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery = GetEntityQuery(new EntityQueryDesc");
                    builder.OpenBraces();
                    builder.AppendLine($"All = new []");
                    builder.OpenBraces();
                    builder.AppendLine($"ComponentType.ReadWrite<{eventViewType.Name}>(),");
                    builder.AppendLine($"ComponentType.ReadOnly<RemovedComponentArrayData>(),");
                    builder.CloseBraces();
                    builder.CloseBraces(");");
                    builder.AppendLine();
                }

                builder.AppendLine($"_removedComponentArrayDataROComponentTypeHandle = GetComponentTypeHandle<RemovedComponentArrayData>(true);");
            }

            builder.CloseBraces();
            builder.AppendLine();

            // OnUpdate
            builder.AppendLine($"protected override void OnUpdate()");
            builder.OpenBraces();
            if (hasDirtyEventViewTypes)
            {
                foreach (var eventViewType in dirtyEventViewTypes)
                {
                    builder.AppendLine($"_{typeSymbol.Name}ROComponentTypeHandle.Update(this);");
                    builder.AppendLine($"var notify{eventViewType.Name}{typeSymbol.Name}DirtyJob = new Notify{typeSymbol.Name}DirtyJob<{eventViewType.Name}>");
                    builder.OpenBraces();
                    builder.AppendLine($"EntityManager = this.EntityManager,");
                    builder.AppendLine($"DataTypeHandle = _{typeSymbol.Name}ROComponentTypeHandle,");
                    builder.AppendLine($"ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.Name}>(false)");
                    builder.CloseBraces(";");
                    builder.AppendLine($"CompleteDependency();");
                    builder.AppendLine($"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}{typeSymbol.Name}DirtyJob, _entityWith{eventViewType.Name}And{typeSymbol.Name}Query);");
                    builder.AppendLine();
                }

                builder.AppendLine($"_{typeSymbol.Name}RWComponentTypeHandle.Update(this);");
                builder.AppendLine($"var job{typeSymbol.Name}ResetDirty = new {typeSymbol.Name}ResetDirtyJob");
                builder.OpenBraces();
                builder.AppendLine($"DataTypeHandle = _{typeSymbol.Name}RWComponentTypeHandle,");
                builder.CloseBraces(";");
                builder.AppendLine($"CompleteDependency();");
                builder.AppendLine($"JobEntityBatchExtensions.RunWithoutJobs(ref job{typeSymbol.Name}ResetDirty, _entityWith{typeSymbol.Name}Query);");
            }

            if (hasAddedEventViewTypes)
            {
                builder.AppendLine($"_addedComponentArrayDataROComponentTypeHandle.Update(this);");
                foreach (var eventViewType in addedEventViewTypes)
                {
                    builder.AppendLine();
                    builder.AppendLine($"var notify{eventViewType.Name}Add{typeSymbol.Name}Job = new NotifyAdd{typeSymbol.Name}Job<{eventViewType.Name}>");
                    builder.OpenBraces();
                    builder.AppendLine($"EntityManager = this.EntityManager,");
                    builder.AppendLine($"DataTypeHandle = _addedComponentArrayDataROComponentTypeHandle,");
                    builder.AppendLine($"ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.Name}>(false),");
                    builder.CloseBraces(";");
                    builder.AppendLine($"CompleteDependency();");
                    builder.AppendLine($"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}Add{typeSymbol.Name}Job, _entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery);");
                }
            }

            if (hasRemovedEventViewTypes)
            {
                builder.AppendLine($"_removedComponentArrayDataROComponentTypeHandle.Update(this);");
                foreach (var eventViewType in removedEventViewTypes)
                {
                    builder.AppendLine();
                    builder.AppendLine($"var notify{eventViewType.Name}Remove{typeSymbol.Name}Job = new NotifyRemove{typeSymbol.Name}Job<{eventViewType.Name}>");
                    builder.OpenBraces();
                    builder.AppendLine($"EntityManager = this.EntityManager,");
                    builder.AppendLine($"DataTypeHandle = _removedComponentArrayDataROComponentTypeHandle,");
                    builder.AppendLine($"ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.Name}>(false),");
                    builder.CloseBraces(";");
                    builder.AppendLine($"CompleteDependency();");
                    builder.AppendLine($"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}Remove{typeSymbol.Name}Job, _entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery);");
                }
            }

            builder.CloseBraces();
            if (hasDirtyEventViewTypes)
            {
                builder.AppendLine();
                GenerateNotifyDirtyJob();
                builder.AppendLine();
                GenerateResetDirtyJob();
            }

            if (hasAddedEventViewTypes)
            {
                builder.AppendLine();
                GenerateNotifyAddJob();
            }

            if (hasRemovedEventViewTypes)
            {
                builder.AppendLine();
                GenerateNotifyRemoveJob();
            }

            builder.CloseBraces();
            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "EventSystem", SourceText.From(builder.ToString(), Encoding.UTF8));

            void GenerateNotifyDirtyJob()
            {
                var fields = typeSymbol.GetMembers().OfType<IFieldSymbol>()
                    .Where(field => field.HasAttribute("MarkDirty"));

                builder.AppendLine($"private struct Notify{typeSymbol.Name}DirtyJob<T> : IJobEntityBatch where T : class, I{GetNameRootFromEventComponentType(typeSymbol)}Listener");
                builder.OpenBraces();
                builder.AppendLine($"public EntityManager EntityManager;");
                builder.AppendLine($"public ComponentTypeHandle<{typeSymbol.Name}> DataTypeHandle;");
                builder.AppendLine($"public ComponentTypeHandle<T> ListenerTypeHandle;");
                builder.AppendLine();
                builder.AppendLine($"public void Execute(ArchetypeChunk batchInChunk, int batchIndex)");
                builder.OpenBraces();
                builder.AppendLine($"var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);");
                builder.AppendLine($"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);");
                builder.AppendLine($"for (int i = 0; i < batchInChunk.Count; i++)");
                builder.OpenBraces();
                builder.AppendLine($"var data = dataArray[i];");
                builder.AppendLine($"var listener = listenerAccessor[i];");
                builder.AppendLine($"if (data.IsDirty && listener != null)");
                builder.OpenBraces();
                builder.AppendLine($"listener.On{GetNameRootFromEventComponentType(typeSymbol)}Changed({string.Join(", ", fields.Select(field => "data." + field.Name))});");
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces(); // Execute
                builder.CloseBraces(); // struct
            }

            void GenerateResetDirtyJob()
            {
                builder.AppendLine($"private struct {typeSymbol.Name}ResetDirtyJob : IJobEntityBatch");
                builder.OpenBraces();
                builder.AppendLine($"public ComponentTypeHandle<{typeSymbol.Name}> DataTypeHandle;");
                builder.AppendLine();
                builder.AppendLine($"public void Execute(ArchetypeChunk batchInChunk, int batchIndex)");
                builder.OpenBraces();
                builder.AppendLine($"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);");
                builder.AppendLine($"for (int i = 0; i < batchInChunk.Count; i++)");
                builder.OpenBraces();
                builder.AppendLine($"var data = dataArray[i];");
                builder.AppendLine($"if (data.IsDirty)");
                builder.OpenBraces();
                builder.AppendLine($"data.IsDirty = false;");
                builder.CloseBraces();
                builder.AppendLine($"dataArray[i] = data;");
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces();
            }

            void GenerateNotifyAddJob()
            {
                builder.AppendLine($"private struct NotifyAdd{typeSymbol.Name}Job<T> : IJobEntityBatch where T : class, I{GetNameRootFromEventComponentType(typeSymbol)}AddedListener");
                builder.OpenBraces();
                builder.AppendLine($"public EntityManager EntityManager;");
                builder.AppendLine($"public ComponentTypeHandle<AddedComponentArrayData> DataTypeHandle;");
                builder.AppendLine($"public ComponentTypeHandle<T> ListenerTypeHandle;");
                builder.AppendLine();
                builder.AppendLine($"public void Execute(ArchetypeChunk batchInChunk, int batchIndex)");
                builder.OpenBraces();
                builder.AppendLine($"var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);");
                builder.AppendLine($"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);");
                builder.AppendLine($"for (int i = 0; i < batchInChunk.Count; i++)");
                builder.OpenBraces();
                builder.AppendLine($"var data = dataArray[i];");
                builder.AppendLine($"var listener = listenerAccessor[i];");
                builder.AppendLine($"for (int j = 0; j < data.Value.Length; j++)");
                builder.OpenBraces();
                builder.AppendLine($"if (data.Value[j] == ComponentType.ReadWrite<{typeSymbol.Name}>().TypeIndex)");
                builder.OpenBraces();
                builder.AppendLine($"listener.On{GetNameRootFromEventComponentType(typeSymbol)}Added();");
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces(); // Execute
                builder.CloseBraces(); // struct
            }

            void GenerateNotifyRemoveJob()
            {
                builder.AppendLine($"private struct NotifyRemove{typeSymbol.Name}Job<T> : IJobEntityBatch where T : class, I{GetNameRootFromEventComponentType(typeSymbol)}RemovedListener");
                builder.OpenBraces();
                builder.AppendLine($"public EntityManager EntityManager;");
                builder.AppendLine($"public ComponentTypeHandle<RemovedComponentArrayData> DataTypeHandle;");
                builder.AppendLine($"public ComponentTypeHandle<T> ListenerTypeHandle;");
                builder.AppendLine();
                builder.AppendLine($"public void Execute(ArchetypeChunk batchInChunk, int batchIndex)");
                builder.OpenBraces();
                builder.AppendLine($"var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);");
                builder.AppendLine($"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);");
                builder.AppendLine($"for (int i = 0; i < batchInChunk.Count; i++)");
                builder.OpenBraces();
                builder.AppendLine($"var data = dataArray[i];");
                builder.AppendLine($"var listener = listenerAccessor[i];");
                builder.AppendLine($"for (int j = 0; j < data.Value.Length; j++)");
                builder.OpenBraces();
                builder.AppendLine($"if (data.Value[j] == ComponentType.ReadWrite<{typeSymbol.Name}>().TypeIndex)");
                builder.OpenBraces();
                builder.AppendLine($"listener.On{GetNameRootFromEventComponentType(typeSymbol)}Removed();");
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces(); // Execute
                builder.CloseBraces(); // struct
            }
        }
    }

    private static List<ITypeSymbol> GetDirtyTypes(Compilation compilation, ITypeSymbol typeSymbol, List<ClassDeclarationSyntax> classCandidates, string SearchAttributeName)
    {        
        return classCandidates.Where(eventType =>
        {
            var onDirtyEventViewAttribute = eventType.AttributeLists.FindAttribute(SearchAttributeName);
            var model = compilation.GetSemanticModel(eventType.SyntaxTree);
            var dirtyViewTypes = ExtractTypesFromAttribute(onDirtyEventViewAttribute, model);
            return dirtyViewTypes.Contains(typeSymbol);
        }).Select(eventType =>
        {
            var model = compilation.GetSemanticModel(eventType.SyntaxTree);
            ITypeSymbol eventTypeSymbol = (ITypeSymbol)model.GetDeclaredSymbol(eventType);
            return eventTypeSymbol;
        }).ToList();
    }

    private static void GenerateEventViewInterfaceFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentWithEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            var onDirtyEventViewAttribute = type.AttributeLists.FindAttribute("OnDirtyEventView");
            var dirtyViewTypes = ExtractTypesFromAttribute(onDirtyEventViewAttribute, model).Select(typeInfo =>
            {
                return $"I{GetNameRootFromEventComponentType(typeInfo)}Listener";
            });
            var onAddedEventViewAttribute = type.AttributeLists.FindAttribute("OnAddedEventView");
            var addedViewTypes = ExtractTypesFromAttribute(onAddedEventViewAttribute, model).Select(typeInfo =>
            {
                return $"I{GetNameRootFromEventComponentType(typeInfo)}AddedListener";
            });
            var onRemovedEventViewAttribute = type.AttributeLists.FindAttribute("OnRemovedEventView");
            var removedViewTypes = ExtractTypesFromAttribute(onRemovedEventViewAttribute, model).Select(typeInfo =>
            {
                return $"I{GetNameRootFromEventComponentType(typeInfo)}RemovedListener";
            });
            string interfacesList = string.Join(", ", dirtyViewTypes.Union(addedViewTypes).Union(removedViewTypes));
            var name = typeSymbol.Name;
            builder.AppendLine($@"public partial class {name} : {interfacesList}");
            builder.OpenBraces();
            builder.CloseBraces();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "Event", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateReadWriteEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ReadWriteEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            var readWriteEcsAttribute = type.AttributeLists.FindAttribute("ReadWriteEcs");
            var readWriteEcsTypes = ExtractTypesFromAttribute(readWriteEcsAttribute, model);
            var name = typeSymbol.Name;
            builder.AppendLine($@"public partial class {name}");
            builder.OpenBraces();
            foreach (var readWriteEcsProperty in readWriteEcsTypes)
            {
                builder.AppendLine($"public {readWriteEcsProperty.Name} {readWriteEcsProperty.Name}");
                builder.OpenBraces();
                builder.AppendLine($"get => EntityManager.GetComponentData<{readWriteEcsProperty.Name}>(LinkedEntity);");
                builder.AppendLine($"set => EntityManager.SetComponentData(LinkedEntity, value);");
                builder.CloseBraces();
            }
            builder.CloseBraces();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "ReadWrite", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateHasComponentEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.HasComponentEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            var hasComponentEcsAttribute = type.AttributeLists.FindAttribute("HasComponentEcs");
            var hasComponentEcsTypes = ExtractTypesFromAttribute(hasComponentEcsAttribute, model);
            var name = typeSymbol.Name;
            builder.AppendLine($@"public partial class {name}");
            builder.OpenBraces();
            foreach (var readWriteEcsProperty in hasComponentEcsTypes)
            {
                builder.AppendLine($"public bool Has{readWriteEcsProperty.Name} => EntityManager.HasComponent<{readWriteEcsProperty.Name}>(LinkedEntity);");
            }
            builder.CloseBraces();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "HasComponent", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static IEnumerable<ITypeSymbol> ExtractTypesFromAttribute(AttributeSyntax attributeSyntax, SemanticModel model)
    {
        if (attributeSyntax == null)
        {
            return Array.Empty<ITypeSymbol>();
        }

        var typeOfExpressions = attributeSyntax.ArgumentList.Arguments.Select(_ => _.Expression).OfType<TypeOfExpressionSyntax>();
        var validTypes = typeOfExpressions.Select(typeOfExpression => model.GetTypeInfo(typeOfExpression.Type)).Where(_ => _.Type != null).Select(_ => _.Type!);
        return validTypes;
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private static string LowercaseName(string identifier)
    {
        return identifier.Substring(0, 1).ToLowerInvariant() + identifier.Substring(1);
    }

    /// <summary>
    /// ComponentData struct usually suffix with Tag or Data indicating what they are used for.
    /// In order to generate related system or partial structs, those suffix are stripped in order to get the name of the ComponentData struct.
    /// </summary>
    /// <param name="eventComponentType"></param>
    /// <returns></returns>
    private static string GetNameRootFromEventComponentType(ITypeSymbol eventComponentType)
    {
        var typeName = eventComponentType.Name;
        if (typeName.EndsWith("Tag"))
        {
            return typeName.Substring(0, typeName.Length - 3);
        }
        else if (typeName.EndsWith("Data"))
        {
            return typeName.Substring(0, typeName.Length - 4);
        }
        else
        {
            return typeName;
        }
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<StructDeclarationSyntax> ComponentDirtyEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ComponentWithEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ReadWriteEcs { get; } = new();
        public List<ClassDeclarationSyntax> HasComponentEcs { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context is StructDeclarationSyntax structDeclarationSyntax
                && structDeclarationSyntax.AttributeLists.Count > 0)
            {
                var componentDirtyEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentDirtyEventAttributeType);
                var componentRemovedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentRemovedEventAttributeType);
                var componentAddedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentAddedEventAttributeType);
                var codeGenNetComponentAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(CodeGenNetComponentAttributeType);
                if (componentDirtyEventAttribute != null || codeGenNetComponentAttribute != null
                    || componentRemovedEventAttribute != null || componentAddedEventAttribute != null)
                {
                    this.ComponentDirtyEventStructs.Add(structDeclarationSyntax);
                }
            }

            if (context is ClassDeclarationSyntax classtDeclarationSyntax
                && classtDeclarationSyntax.AttributeLists.Count > 0)
            {
                var onAddedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("OnAddedEventView");
                var onRemovedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("OnRemovedEventView");
                var onDirtyEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("OnDirtyEventView");
                if (onAddedEventViewAttribute != null || onRemovedEventViewAttribute != null || onDirtyEventViewAttribute != null)
                {
                    this.ComponentWithEventStructs.Add(classtDeclarationSyntax);
                }

                var readWriteEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("ReadWriteEcs");
                if (readWriteEcsAttribute != null)
                {
                    this.ReadWriteEcs.Add(classtDeclarationSyntax);
                }

                var hasComponentEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("HasComponentEcs");
                if (hasComponentEcsAttribute != null)
                {
                    this.HasComponentEcs.Add(classtDeclarationSyntax);
                }
            }
        }
    }
}
