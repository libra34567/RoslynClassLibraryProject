using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using CsCodeGenerator;
using CsCodeGenerator.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace LittleToySourceGenerator;

[Generator]
public class Generator : ISourceGenerator
{
    public bool EnableEventDataGeneration { get; set; } = true;
    public bool EnableEventSystemGeneration { get; set; } = true;
    public bool GenerateEventViewInterfaceGeneration { get; set; } = true;
    public bool EnableReadWriteEcsGeneration { get; set; } = true;
    public bool EnableNetMessageGeneration { get; set; } = true;
    public bool EnableNetworkComponentGeneration { get; set; } = true;

    public const string ComponentDirtyEventAttributeType = "ComponentDirtyEvent";

    public const string CodeGenNetComponentAttributeType = "CodeGenNetComponent";

    public const string MarkDirtyAttributeType = "MarkDirty";

    public const string SyncFieldAttributeType = "SyncField";

    public const string ComponentRemovedEventAttributeType = "ComponentRemovedEvent";

    public const string ComponentAddedEventAttributeType = "ComponentAddedEvent";

    public const string ReadWriteEcsAttributeType = "ReadWriteEcs";

    public const string HasComponentEcsAttributeType = "HasComponentEcs";
    public const string OnAddedEventViewAttributeType = "OnAddedEventView";
    public const string OnRemovedEventViewAttributeType = "OnRemovedEventView";
    public const string OnDirtyEventViewAttributeType = "OnDirtyEventView";
    public const string CodeGenNetMessageAttributeType = "CodeGenNetMessage";

    private const string FileHeader = @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591";

    private static DiagnosticDescriptor FieldTypeShouldBeKnownForDotsNet = new DiagnosticDescriptor(
        "LT0001",
        "Field type should be known to DOTSNET", 
        "Cannot convert field type {0} to dotsnet read/write methods",
        "LittleToy",
        DiagnosticSeverity.Error, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static DiagnosticDescriptor NetComponentShouldHaveSyncField = new DiagnosticDescriptor(
        "LT0002",
        "Net component should have SyncField",
        "Type {0} does not have any field marked with SyncFieldAttribute",
        "LittleToy",
        DiagnosticSeverity.Error, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static DiagnosticDescriptor EventSystemTypesShouldHaveAttribute = new DiagnosticDescriptor(
        "LT0003",
        "EventSystem types should use appropriate types",
        "Type {0} used with {1} attribute but do not marked with {2}.",
        "LittleToy",
        DiagnosticSeverity.Warning, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    private static Dictionary<string, string> _systemToDotsnetTypeDictionary = new Dictionary<string, string>()
    {
        { "System.Byte", "Byte"},
        { "System.Boolean", "Bool"},
        { "System.Int16", "Short"},
        { "System.UInt16", "UShort"},
        { "System.Int32", "Int"},
        { "System.UInt32", "UInt"},
        { "Unity.Mathematics.int2", "Int2" },
        { "Unity.Mathematics.int3", "Int3" },
        { "Unity.Mathematics.int4", "Int4" },
        { "System.UInt64", "ULong" },
        { "System.Int64", "Long" },
        { "DOTSNET.long3", "Long3" },
        { "System.Single", "Float" },
        { "Unity.Mathematics.float2", "Float2" },
        { "Unity.Mathematics.float3", "Float3" },
        { "Unity.Mathematics.float4", "Float4" },
        { "System.Double", "Double"},
        { "Unity.Mathematics.double2", "Double2" },
        { "Unity.Mathematics.double3", "Double3" },
        { "Unity.Mathematics.double4", "Double4" },
        { "System.Decimal", "Decimal"},
        { "Unity.Mathematics.quaternion", "Quaternion"},
        { "Unity.Collections.FixedBytes16", "Bytes16"},
        { "Unity.Collections.FixedBytes30", "Bytes30"},
        { "Unity.Collections.FixedBytes62", "Bytes62"},
        { "Unity.Collections.FixedBytes126", "Bytes126"},
        { "Unity.Collections.FixedBytes510", "Bytes510"},
        { "Unity.Collections.FixedBytes4094", "Bytes4094"},
        { "Unity.Collections.FixedString32Bytes", "FixedString32"},
        { "Unity.Collections.FixedString64Bytes", "FixedString64"},
        { "Unity.Collections.FixedString128Bytes", "FixedString128"},
        { "Unity.Collections.FixedString512Bytes", "FixedString512"}
    };

    public void DisableAllGeneration()
    {
        EnableEventDataGeneration = false;
        EnableEventSystemGeneration = false;
        GenerateEventViewInterfaceGeneration = false;
        EnableReadWriteEcsGeneration = false;
        EnableNetMessageGeneration = false;
        EnableNetworkComponentGeneration = false;
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        if (EnableEventDataGeneration)
        {
            GenerateEventDataFiles(context, receiver);
        }

        if (EnableEventSystemGeneration)
        {
            GenerateEventSystemFiles(context, receiver);
        }

        if (GenerateEventViewInterfaceGeneration)
        {
            GenerateEventViewInterfaceFiles(context, receiver);
        }

        if (EnableReadWriteEcsGeneration)
        {
            GenerateReadWriteEcsFiles(context, receiver);
            GenerateHasComponentEcsFiles(context, receiver);
        }

        if (EnableNetMessageGeneration)
        {
            GenerateNetMessageFiles(context, receiver);
        }

        if (EnableNetworkComponentGeneration)
        {
            GenerateNetworkComponentFiles(context, receiver);
        }
    }

    private static void GenerateEventDataFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateEventData(typeSymbol, context, type);
            context.AddSource(typeSymbol.Name + "EventData", SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateEventData(ITypeSymbol eventComponentType, GeneratorExecutionContext context, SyntaxNode syntaxNode)
    {
        var file = new FileModel(eventComponentType.Name + "EventData")
        {
            UsingDirectives = new List<string>
            {
                "System;",
                "Unity.Entities;",
                "Unity.Mathematics;",
                "Plugins.basegame.Events;",
                "DOTSNET;",
                "Unity.Collections;"
            },
            Namespace = eventComponentType.ContainingNamespace?.Name ?? "",
            Header = FileHeader,
        };

        // Generate methods and properties used for dirty event of ComponentData
        if (eventComponentType.HasAttribute(ComponentDirtyEventAttributeType) || eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            // Create the StructModel used for code generation
            file.Structs.Add(GenerateEventStructModel(eventComponentType, context, syntaxNode));
        }

        // Generate listeners required for each type of event add/remove/dirty
        file.Interfaces.Add(GenerateComponentDirtyEventInterfaceModel(eventComponentType));
        file.Interfaces.Add(GenerateComponentRemovedEventInterfaceModel(eventComponentType));
        file.Interfaces.Add(GenerateComponentAddedEventInterface(eventComponentType));
        return file;
    }

    /// <summary>
    /// Generate the struct model used for code generation
    /// </summary>
    /// <param name="eventComponentType">Component type for which generate EventData structure implementation.</param>
    /// <param name="context">Code generation context in which generate the struct.</param>
    /// <param name="syntaxNode">Syntax node for which attempt to generate code happens.</param>
    /// <returns>A <see cref="StructModel"/> representing generated component.</returns>
    private static StructModel GenerateEventStructModel(ITypeSymbol eventComponentType, GeneratorExecutionContext context, SyntaxNode syntaxNode)
    {
        //Only generate IfDirty Property if there's any field marked with [MarkDirty] attribute
        var needIfDirty = false;
        foreach (var fieldInfo in eventComponentType.GetFields())
        {
            if (fieldInfo.HasAttribute(MarkDirtyAttributeType))
            {
                needIfDirty = true;
                break;
            }
        }

        var structModel = new StructModel(eventComponentType.Name)
        {
            SingleKeyWord = KeyWord.Partial,
            Properties = new List<Property>(),
            Interfaces = new List<string>()
        };

        if (needIfDirty)
        {
            structModel.Properties.Add(new Property(BuiltInDataType.Bool, "IsDirty")
            {
                AccessModifier = AccessModifier.Public
            });
        }

        // Implement NetworkComponent interface if has attribute CodeGenNetComponent
        if (eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            structModel.Interfaces.Add("NetworkComponent");
        }

        // Generate update method, when there's at least one field with MarkDirty and without SyncField attribute
        // the Update method used to update the fields/properties of the struct then mark the struct as dirty.
        List<IFieldSymbol> fieldsWithMarkDirtyAndWithoutSyncField = new List<IFieldSymbol>();
        foreach (var fieldInfo in eventComponentType.GetFields())
        {
            if (fieldInfo.HasAttribute(MarkDirtyAttributeType) &&
                fieldInfo.HasAttribute(SyncFieldAttributeType) == false)
            {
                fieldsWithMarkDirtyAndWithoutSyncField.Add(fieldInfo);
            }
        }

        if (fieldsWithMarkDirtyAndWithoutSyncField.Count > 0)
        {
            var method = new Method(BuiltInDataType.Void, "Update")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>(),
                BodyLines = new List<string>()
                {
                    "if(",
                    "",
                    "IsDirty = true;"
                },
                CustomDataType = eventComponentType.Name
            };

            var isFirst = true;

            // The body of the update method
            foreach (var fieldInfo in fieldsWithMarkDirtyAndWithoutSyncField)
            {
                string parameterName = fieldInfo.Name.LowerFirst();
                if (parameterName == fieldInfo.Name)
                {
                    parameterName += "_";
                }

                method.Parameters.Add(new Parameter()
                {
                    CustomDataType = fieldInfo.Type.Name,
                    Name = parameterName
                });

                if (!isFirst)
                    method.BodyLines[0] += " && ";

                method.BodyLines[0] += $"{fieldInfo.Name}.Equals({parameterName})";
                isFirst = false;

                method.BodyLines.Add($"{fieldInfo.Name} = {parameterName};");
            }

            method.BodyLines[0] += ") return this;";

            method.BodyLines.Add("");
            method.BodyLines.Add("return this;");

            structModel.Methods.Add(method);
        }

        if (eventComponentType.HasAttribute(CodeGenNetComponentAttributeType))
        {
            // Generate the GetSyncDirection Method
            var syncDir = eventComponentType.GetCustomAttribute(CodeGenNetComponentAttributeType).GetFieldValue("SyncDirection");
            var GetSyncDirectionMethodModel = new Method("SyncDirection", "GetSyncDirection")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>(),
                BodyLines = new List<string>()
                {
                    $"return SyncDirection.{syncDir.ToString()};"
                },
            };
            structModel.Methods.Add(GetSyncDirectionMethodModel);

            // Get syncField field list
            var fieldWithSyncFieldAttribute = new List<IFieldSymbol>();
            var fieldWithSyncFieldAndMarkDirtyAttribute = new List<IFieldSymbol>();

            foreach (var fieldInfo in eventComponentType.GetFields())
            {
                if (fieldInfo.HasAttribute(SyncFieldAttributeType))
                {
                    fieldWithSyncFieldAttribute.Add(fieldInfo);
                    if (fieldInfo.HasAttribute(MarkDirtyAttributeType))
                    {
                        fieldWithSyncFieldAndMarkDirtyAttribute.Add(fieldInfo);
                    }
                }
            }

            if (fieldWithSyncFieldAttribute.Count == 0)
            {
                var err = Diagnostic.Create(NetComponentShouldHaveSyncField, location: syntaxNode.GetLocation(), eventComponentType.Name);
                context.ReportDiagnostic(err);
            }

            var serializeMethodModel = new Method(BuiltInDataType.Bool, "Serialize")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter>
                {
                    new Parameter("ref NetworkWriter128 writer")
                },
                BodyLines = new List<string>()
                {
                    "return"
                },
            };

            for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
            {
                var fieldInfo = fieldWithSyncFieldAttribute[i];
                var fieldType = fieldInfo.Type;

                if (IsDotsnetType(fieldType) == false)
                {
                    var err = Diagnostic.Create(FieldTypeShouldBeKnownForDotsNet, location: syntaxNode.GetLocation(), fieldType.Name);
                    context.ReportDiagnostic(err);
                    return structModel;
                }

                if (i == fieldWithSyncFieldAttribute.Count - 1)
                {
                    // last one
                    serializeMethodModel.BodyLines[0] += $" writer.Write{GetDotsnetTypeName(fieldType)}({fieldInfo.Name});";
                }
                else
                {
                    serializeMethodModel.BodyLines[0] += $" writer.Write{GetDotsnetTypeName(fieldType)}({fieldInfo.Name}) &&";
                }
            }

            structModel.Methods.Add(serializeMethodModel);

            var shouldDealWithDirtyInDeserialize = fieldWithSyncFieldAndMarkDirtyAttribute.Count > 0;
            var deserializeMethodModel = new Method(BuiltInDataType.Bool, "Deserialize")
            {
                AccessModifier = AccessModifier.Public,
                Parameters = new List<Parameter> { new Parameter("ref NetworkReader128 reader") },
            };

            if (shouldDealWithDirtyInDeserialize)
            {
                deserializeMethodModel.BodyLines = new List<string>()
                {
                    "if (",
                    "{",
                    "    if (",
                    "    {",
                    "        IsDirty = true;",
                };
            }
            else
            {
                deserializeMethodModel.BodyLines = new List<string>()
                {
                    "return"
                };
            }

            if (shouldDealWithDirtyInDeserialize)
            {
                for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
                {
                    var fieldInfo = fieldWithSyncFieldAttribute[i];
                    var fieldType = fieldInfo.Type;

                    if (IsDotsnetType(fieldType) == false)
                    {
                        var err = Diagnostic.Create(FieldTypeShouldBeKnownForDotsNet, location: syntaxNode.GetLocation(), fieldType.Name);
                        context.ReportDiagnostic(err);
                        return structModel;
                    }

                    if (i == 0)
                    {
                        if (fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo))
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $"reader.Read{GetDotsnetTypeName(fieldType)}(out var {fieldInfo.Name.ToLower()})";
                            deserializeMethodModel.BodyLines[2] +=
                                $"{fieldInfo.Name} != {fieldInfo.Name.ToLower()}";
                            deserializeMethodModel.BodyLines.Add(
                                $"        {fieldInfo.Name} = {fieldInfo.Name.ToLower()};");
                        }
                        else
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $"reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name})";
                        }
                    }
                    else
                    {
                        if (fieldWithSyncFieldAndMarkDirtyAttribute.Contains(fieldInfo))
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $" && reader.Read{GetDotsnetTypeName(fieldType)}(out var {fieldInfo.Name.ToLower()})";
                            deserializeMethodModel.BodyLines[2] +=
                                $" || {fieldInfo.Name} != {fieldInfo.Name.ToLower()}";
                            deserializeMethodModel.BodyLines.Add(
                                $"        {fieldInfo.Name} = {fieldInfo.Name.ToLower()};");
                        }
                        else
                        {
                            deserializeMethodModel.BodyLines[0] +=
                                $" && reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name})";
                        }
                    }
                }

                deserializeMethodModel.BodyLines[0] += ")";
                deserializeMethodModel.BodyLines[2] += ")";

                deserializeMethodModel.BodyLines.Add("    }");
                deserializeMethodModel.BodyLines.Add("    return true;");
                deserializeMethodModel.BodyLines.Add("}");
                deserializeMethodModel.BodyLines.Add("return false;");
            }
            else
            {
                for (var i = 0; i < fieldWithSyncFieldAttribute.Count; i++)
                {
                    var fieldInfo = fieldWithSyncFieldAttribute[i];
                    var fieldType = fieldInfo.Type;

                    if (IsDotsnetType(fieldType) == false)
                    {
                        var err = Diagnostic.Create(FieldTypeShouldBeKnownForDotsNet, location: syntaxNode.GetLocation(), fieldType.Name);
                        context.ReportDiagnostic(err);
                        return structModel;
                    }

                    if (i == fieldWithSyncFieldAttribute.Count - 1)
                    {
                        // last one
                        deserializeMethodModel.BodyLines[0] +=
                            $" reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name});";
                    }
                    else
                    {
                        deserializeMethodModel.BodyLines[0] +=
                            $" reader.Read{GetDotsnetTypeName(fieldType)}(out {fieldInfo.Name}) &&";
                    }
                }
            }

            structModel.Methods.Add(deserializeMethodModel);
        }

        return structModel;
    }

    /// <summary>
    /// Generate listeners required for ComponentData dirty event, this is used in ViewClasses to receive events
    /// </summary>
    /// <param name="eventComponentType">Component type for which generate IXXXListener interface declaration.</param>
    /// <returns>An <see cref="InterfaceModel"/> for generated IXXXListener interface or null if interface would not be generated.</returns>
    private static InterfaceModel GenerateComponentDirtyEventInterfaceModel(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentDirtyEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);

        var interfaceModel = new InterfaceModel($"I{nameRoot}Listener")
        {
            AccessModifier = AccessModifier.Public
        };
        var method = new Method(BuiltInDataType.Void, $"On{nameRoot}Changed")
        {
            Parameters = new List<Parameter>(),
            WithoutBody = true
        };

        foreach (var fieldInfo in eventComponentType.GetFields())
        {
            if (fieldInfo.Name == "IsDirty" || fieldInfo.GetAttributes().All(attr => !attr.IsAttribute(MarkDirtyAttributeType)))
            {
                continue;
            }

            method.Parameters.Add(new Parameter()
            {
                CustomDataType = fieldInfo.Type.Name,
                Name = fieldInfo.Name.LowerFirst()
            });
        }

        interfaceModel.Methods.Add(method);
        return interfaceModel;
    }

    // Generate listeners required for ComponentData removed event, this is used in ViewClasses to receive events
    private static InterfaceModel GenerateComponentRemovedEventInterfaceModel(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentRemovedEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var interfaceModel = new InterfaceModel($"I{nameRoot}RemovedListener")
        {
            AccessModifier = AccessModifier.Public,
            Methods = new List<Method>
            {
                new Method(BuiltInDataType.Void, $"On{nameRoot}Removed")
                {
                    Parameters = new List<Parameter>(),
                    WithoutBody = true
                }
            }
        };

        return interfaceModel;
    }

    // Generate listeners required for ComponentData added event, this is used in ViewClasses to receive events
    private static InterfaceModel GenerateComponentAddedEventInterface(ITypeSymbol eventComponentType)
    {
        var hasMarker = eventComponentType.GetCustomAttributes(true).Any(attribute => attribute.IsAttribute(ComponentAddedEventAttributeType));
        if (!hasMarker)
        {
            return null;
        }

        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var interfaceModel = new InterfaceModel($"I{nameRoot}AddedListener")
        {
            AccessModifier = AccessModifier.Public,
            Methods = new List<Method>
            {
                new Method(BuiltInDataType.Void, $"On{nameRoot}Added")
                {
                    Parameters = new List<Parameter>(),
                    WithoutBody = true
                }
            }
        };

        return interfaceModel;
    }

    private static string GetFullyQualifiedName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.SpecialType switch
        {
            SpecialType.System_Byte => "System.Byte",
            SpecialType.System_Boolean => "System.Boolean",
            SpecialType.System_SByte => "System.SByte",
            SpecialType.System_Single => "System.Single",
            SpecialType.System_Double => "System.Double",
            SpecialType.System_Decimal => "System.Decimal",
            SpecialType.System_Int16 => "System.Int16",
            SpecialType.System_Int32 => "System.Int32",
            SpecialType.System_Int64 => "System.Int64",
            SpecialType.System_UInt16 => "System.UInt16",
            SpecialType.System_UInt32 => "System.UInt32",
            SpecialType.System_UInt64 => "System.UInt64",
            _ => typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty),
        };
    }

    private static bool IsDotsnetType(ITypeSymbol typeSymbol)
    {
        return _systemToDotsnetTypeDictionary.ContainsKey(GetFullyQualifiedName(typeSymbol));
    }

    private static string GetDotsnetTypeName(ITypeSymbol typeSymbol)
    {
        return _systemToDotsnetTypeDictionary[GetFullyQualifiedName(typeSymbol)];
    }

    private static void GenerateEventSystemFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateEventSystem(context, receiver, type, typeSymbol, context.Compilation.AssemblyName != "Assembly-CSharp-firstpass" ? string.Empty : "BaseGame");
            
            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }

        foreach (var type in receiver.ComponentWithEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            Validate(OnDirtyEventViewAttributeType, ComponentDirtyEventAttributeType);
            Validate(OnAddedEventViewAttributeType, ComponentAddedEventAttributeType);
            Validate(OnRemovedEventViewAttributeType, ComponentRemovedEventAttributeType);

            void Validate(string marker, string expectedAttribute)
            {
                var onDirtyEventViewAttribute = typeSymbol.GetCustomAttribute(marker);
                if (onDirtyEventViewAttribute != null)
                {
                    var typesToCheck = onDirtyEventViewAttribute.GetFieldValueTypes("Types");
                    foreach (var componentDirtyType in typesToCheck)
                    {
                        if (!componentDirtyType.HasAttribute(expectedAttribute))
                        {
                            context.ReportDiagnostic(Diagnostic.Create(EventSystemTypesShouldHaveAttribute, location: type.GetLocation(), componentDirtyType.Name, marker, expectedAttribute));
                            break;
                        }
                    }
                }
            }
        }
    }

    private static FileModel GenerateEventSystem(GeneratorExecutionContext context, SyntaxReceiver receiver, SyntaxNode syntaxNode, ITypeSymbol eventComponentType, string classAddonName)
    {
        var usingDirectives = new List<string>
        {
            "System;",
            "Unity.Entities;",
            "Unity.Mathematics;",
            "Plugins.basegame.Events;",
            "DOTSNET;"
        };

        var file = new FileModel(eventComponentType.Name + "EventSystem" + classAddonName)
        {
            Header = FileHeader,
            Namespace = eventComponentType.ContainingNamespace?.Name ?? "",
        };
        file.LoadUsingDirectives(usingDirectives);

        //the class model used for code generation
        file.Classes.Add(GenerateEventSystemClassModel(context, receiver, syntaxNode, eventComponentType, classAddonName));
        return file;
    }

    private static ClassModel GenerateEventSystemClassModel(GeneratorExecutionContext context, SyntaxReceiver receiver, SyntaxNode syntaxNode, ITypeSymbol eventComponentType, string classAddonName)
    {
        var nameRoot = GetNameRootFromEventComponentType(eventComponentType);
        var classModel = new ClassModel($"{nameRoot}EventSystem" + classAddonName)
        {
            AccessModifier = AccessModifier.Public,
            BaseClass = "SystemBase",
            SingleKeyWord = KeyWord.Partial,
            Fields = new List<Field>(),
            Methods = new List<Method>(),
            NestedClasses = new List<ClassModel>(),
            Attributes = new List<AttributeModel>
            {
                new("UpdateBefore")
                {
                    SingleParameter = new Parameter("typeof(CleanUpAddedRemovedEventSystem)")
                },
                new("ClientWorld"),
                new("UpdateInGroup")
                {
                    Parameters = new List<Parameter>
                    {
                        new("typeof(SimulationSystemGroup)"),
                        new("OrderLast = true")
                    }
                }
            }
        };

        var onCreateMethodModel = new Method(AccessModifier.Protected, KeyWord.Override, BuiltInDataType.Void, "OnCreate");
        onCreateMethodModel.BodyLines.Add("base.OnCreate();");
        classModel.Methods.Add(onCreateMethodModel);

        var onUpdateMethodModel = new Method(AccessModifier.Protected, KeyWord.Override, BuiltInDataType.Void, "OnUpdate");
        classModel.Methods.Add(onUpdateMethodModel);

        List<ClassDeclarationSyntax> classCandidates = receiver.ComponentWithEventStructs;
        var dirtyEventViewTypes = GetDirtyTypes(context.Compilation, eventComponentType, classCandidates, OnDirtyEventViewAttributeType);
        var hasDirtyEventViewTypes = dirtyEventViewTypes.Count > 0;
        var addedEventViewTypes = GetDirtyTypes(context.Compilation, eventComponentType, classCandidates, OnAddedEventViewAttributeType);
        var hasAddedEventViewTypes = addedEventViewTypes.Count > 0;
        var removedEventViewTypes = GetDirtyTypes(context.Compilation, eventComponentType, classCandidates, OnRemovedEventViewAttributeType);
        var hasRemovedEventViewTypes = removedEventViewTypes.Count > 0;

        if (!hasDirtyEventViewTypes && !hasAddedEventViewTypes && !hasRemovedEventViewTypes)
        {
            return null;
        }

        if (hasDirtyEventViewTypes)
        {
            GenerateEventSystemOnDirtyEvents(dirtyEventViewTypes, eventComponentType, classModel, onCreateMethodModel, onUpdateMethodModel);
            GenerateEventSystemOnDirtyEventJobs(eventComponentType, classModel);
            GenerateEventSystemDirtyResetJobs(eventComponentType, classModel);
        }

        if (hasAddedEventViewTypes)
        {
            GenerateEventSystemOnAddedEvents(addedEventViewTypes, eventComponentType, classModel, onCreateMethodModel, onUpdateMethodModel);
            GenerateEventSystemOnAddedEventJobs(eventComponentType, classModel);
        }

        if (hasRemovedEventViewTypes)
        {
            GenerateEventSystemOnRemovedEvents(removedEventViewTypes, eventComponentType, classModel, onCreateMethodModel, onUpdateMethodModel);
            GenerateEventSystemOnRemovedEventJobs(eventComponentType, classModel);
        }

        return classModel;
    }

    private static void GenerateEventSystemOnAddedEvents(IEnumerable<ITypeSymbol> onAddedEventViewTypes, ITypeSymbol eventComponentType,
        ClassModel classModel, Method onCreateMethodModel, Method onUpdateMethodModel)
    {            
        foreach (var eventViewType in onAddedEventViewTypes)
        {
            classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery") {AccessModifier = AccessModifier.Private});
        }
            
        classModel.Fields.Add(new Field($"ComponentTypeHandle<AddedComponentArrayData>", $"_addedComponentArrayDataROComponentTypeHandle") {AccessModifier = AccessModifier.Private});

        foreach (var eventViewType in onAddedEventViewTypes)
        {
            onCreateMethodModel.BodyLines.AddRange(new []
            {
                $"_entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery = GetEntityQuery(new EntityQueryDesc",
                "{",
                $"    All = new []",
                "    {",
                $"        ComponentType.ReadWrite<{eventViewType.Name}>(),",
                $"        ComponentType.ReadOnly<AddedComponentArrayData>(),",
                "    }",
                "});"
            });
        }

        onCreateMethodModel.BodyLines.AddRange(new[]
        {
            "_addedComponentArrayDataROComponentTypeHandle = GetComponentTypeHandle<AddedComponentArrayData>(true);",
            ""
        });               
            
        foreach (var eventViewType in onAddedEventViewTypes)
        {
            onUpdateMethodModel.BodyLines.AddRange(new []
            {
                "_addedComponentArrayDataROComponentTypeHandle.Update(this);",
                $"var notify{eventViewType.Name}Add{eventComponentType.Name}Job = new NotifyAdd{eventComponentType.Name}Job<{eventViewType.Name}>",
                "{",
                "    EntityManager = this.EntityManager,",
                $"    DataTypeHandle = _addedComponentArrayDataROComponentTypeHandle,",
                $"    ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.Name}>(false),",
                "};",
                "CompleteDependency();",
                $"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}Add{eventComponentType.Name}Job, _entityWith{eventViewType.Name}AndAddedComponentArrayDataQuery);",
                ""
            });
        }
    }
        
    private static void GenerateEventSystemOnRemovedEvents(IEnumerable<ITypeSymbol> onRemovedEventViewTypes, ITypeSymbol eventComponentType,
        ClassModel classModel, Method onCreateMethodModel, Method onUpdateMethodModel)
    {            
        foreach (var eventViewType in onRemovedEventViewTypes)
        {
            classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery") {AccessModifier = AccessModifier.Private});
        }
            
        classModel.Fields.Add(new Field($"ComponentTypeHandle<RemovedComponentArrayData>", $"_removedComponentArrayDataROComponentTypeHandle") {AccessModifier = AccessModifier.Private});

        foreach (var eventViewType in onRemovedEventViewTypes)
        {
            onCreateMethodModel.BodyLines.AddRange(new []
            {
                $"_entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery = GetEntityQuery(new EntityQueryDesc",
                "{",
                $"    All = new []",
                "    {",
                $"        ComponentType.ReadWrite<{eventViewType.Name}>(),",
                $"        ComponentType.ReadOnly<RemovedComponentArrayData>(),",
                "    }",
                "});"
            });
        }

        onCreateMethodModel.BodyLines.AddRange(new[]
        {
            "_removedComponentArrayDataROComponentTypeHandle = GetComponentTypeHandle<RemovedComponentArrayData>(true);",
            ""
        });               
            
        foreach (var eventViewType in onRemovedEventViewTypes)
        {
            onUpdateMethodModel.BodyLines.AddRange(new []
            {
                "_removedComponentArrayDataROComponentTypeHandle.Update(this);",
                $"var notify{eventViewType.Name}Remove{eventComponentType.Name}Job = new NotifyRemove{eventComponentType.Name}Job<{eventViewType.Name}>",
                "{",
                "    EntityManager = this.EntityManager,",
                $"    DataTypeHandle = _removedComponentArrayDataROComponentTypeHandle,",
                $"    ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.Name}>(false),",
                "};",
                "CompleteDependency();",
                $"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}Remove{eventComponentType.Name}Job, _entityWith{eventViewType.Name}AndRemovedComponentArrayDataQuery);",
                ""
            });
        }
    }
        
    private static void GenerateEventSystemOnDirtyEvents(IEnumerable<ITypeSymbol> dirtyEventViewTypes, ITypeSymbol eventComponentType,
        ClassModel classModel, Method onCreateMethodModel, Method onUpdateMethodModel)
    {            
        var eventComponentNameCamel = eventComponentType.Name.ToCamel();
        foreach (var eventViewType in dirtyEventViewTypes)
        {
            classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventViewType.Name}And{eventComponentType.Name}Query") {AccessModifier = AccessModifier.Private});
        }
            
        classModel.Fields.Add(new Field("EntityQuery", $"_entityWith{eventComponentType.Name}Query") {AccessModifier = AccessModifier.Private});
        classModel.Fields.Add(new Field($"ComponentTypeHandle<{eventComponentType.Name}>", $"_{eventComponentNameCamel}ROComponentTypeHandle") {AccessModifier = AccessModifier.Private});
        classModel.Fields.Add(new Field($"ComponentTypeHandle<{eventComponentType.Name}>", $"_{eventComponentNameCamel}RWComponentTypeHandle") {AccessModifier = AccessModifier.Private});

        foreach (var eventViewType in dirtyEventViewTypes)
        {
            onCreateMethodModel.BodyLines.AddRange(new []
            {
                $"_entityWith{eventViewType.Name}And{eventComponentType.Name}Query = GetEntityQuery(new EntityQueryDesc",
                "{",
                $"    All = new []",
                "    {",
                $"        ComponentType.ReadWrite<{eventViewType.Name}>(),",
                $"        ComponentType.ReadOnly<{eventComponentType.Name}>(),",
                "    }",
                "});",
                $"_entityWith{eventViewType.Name}And{eventComponentType.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{eventComponentType.Name}>());",
                ""
            });
        }
            
        onCreateMethodModel.BodyLines.AddRange(new []
        {
            $"_entityWith{eventComponentType.Name}Query = GetEntityQuery(new EntityQueryDesc",
            "{",
            $"    All = new []",
            "    {",
            $"        ComponentType.ReadWrite<{eventComponentType.Name}>(),",
            "    }",
            "});",
            $"_entityWith{eventComponentType.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{eventComponentType.Name}>());",
            ""
        });
            
        onCreateMethodModel.BodyLines.AddRange(new []
        {
            $"_{eventComponentNameCamel}ROComponentTypeHandle = GetComponentTypeHandle<{eventComponentType.Name}>(true);",
            $"_{eventComponentNameCamel}RWComponentTypeHandle = GetComponentTypeHandle<{eventComponentType.Name}>(false);",
            ""
        });
            
        foreach (var eventViewType in dirtyEventViewTypes)
        {
            onUpdateMethodModel.BodyLines.AddRange(new []
            {
                $"_{eventComponentNameCamel}ROComponentTypeHandle.Update(this);",
                $"var notify{eventViewType.Name}{eventComponentType.Name}DirtyJob = new Notify{eventComponentType.Name}DirtyJob<{eventViewType.Name}>",
                "{",
                "    EntityManager = this.EntityManager,",
                $"    DataTypeHandle = _{eventComponentNameCamel}ROComponentTypeHandle,",
                $"    ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.Name}>(false),",
                "};",
                "CompleteDependency();",
                $"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}{eventComponentType.Name}DirtyJob, _entityWith{eventViewType.Name}And{eventComponentType.Name}Query);",
                ""
            });
        }
            
        onUpdateMethodModel.BodyLines.AddRange(new []
        {
            $"_{eventComponentNameCamel}RWComponentTypeHandle.Update(this);",
            $"var {eventComponentNameCamel}ResetDirtyJob = new {eventComponentType.Name}ResetDirtyJob",
            "{",
            $"    DataTypeHandle = _{eventComponentNameCamel}RWComponentTypeHandle",
            "};",
            "CompleteDependency();",
            $"JobEntityBatchExtensions.RunWithoutJobs(ref {eventComponentNameCamel}ResetDirtyJob, _entityWith{eventComponentType.Name}Query);",
            ""
        });
    }

    private static List<ITypeSymbol> GetDirtyTypes(Compilation compilation, ITypeSymbol typeSymbol, IEnumerable<TypeDeclarationSyntax> classCandidates, string SearchAttributeName)
    {        
        return classCandidates.Where(eventType =>
        {
            var onDirtyEventViewAttribute = eventType.AttributeLists.FindAttribute(SearchAttributeName);
            var model = compilation.GetSemanticModel(eventType.SyntaxTree);
            var dirtyViewTypes = ExtractTypesFromAttribute(onDirtyEventViewAttribute, model);
            return dirtyViewTypes.Contains(typeSymbol);
        }).Select(eventType =>
        {
            var model = compilation.GetSemanticModel(eventType.SyntaxTree);
            ITypeSymbol eventTypeSymbol = (ITypeSymbol)model.GetDeclaredSymbol(eventType);
            return eventTypeSymbol;
        }).ToList();
    }

    private static void GenerateEventSystemOnDirtyEventJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var parametersToPassInOnChangedListener = "";
        foreach (var fieldInfo in eventComponentType.GetFields())
        {
            if (fieldInfo.HasAttribute(MarkDirtyAttributeType))
            {
                parametersToPassInOnChangedListener += $"data.{fieldInfo.Name}, ";
            }
        }

        parametersToPassInOnChangedListener = parametersToPassInOnChangedListener.Remove(parametersToPassInOnChangedListener.Length - 2, 2);            
        var eventComponentViewDirtyJobStruct = new StructModel($"Notify{eventComponentType.Name}DirtyJob<T>")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch where T : class, {GetDirtyInterfaceForEventComponentOfType(eventComponentType)}"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "EntityManager",
                    Name = "EntityManager",
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<{eventComponentType.Name}>",
                    Name = "DataTypeHandle",
                    Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "ComponentTypeHandle<T>",
                    Name = "ListenerTypeHandle"
                }
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        "var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);",
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                    
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    var listener = listenerAccessor[i];", 
                        "    if (data.IsDirty && listener != null)",
                        "    {",
                        $"        listener.On{GetNameRootFromEventComponentType(eventComponentType)}Changed({parametersToPassInOnChangedListener});",
                        "    }",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewDirtyJobStruct);
    }
        
    private static void GenerateEventSystemOnAddedEventJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var eventComponentViewDirtyJobStruct = new StructModel($"NotifyAdd{eventComponentType.Name}Job<T>")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch where T : class, {GetAddedInterfaceForEventComponentOfType(eventComponentType)}"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "EntityManager",
                    Name = "EntityManager",
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<AddedComponentArrayData>",
                    Name = "DataTypeHandle",
                    Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "ComponentTypeHandle<T>",
                    Name = "ListenerTypeHandle"
                }
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        "var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);",
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                    
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    var listener = listenerAccessor[i];", 
                        "    for (int j = 0; j < data.Value.Length; j++)",
                        "    {",
                        $"        if (data.Value[j] == ComponentType.ReadWrite<{eventComponentType.Name}>().TypeIndex)",
                        "        {",
                        $"            listener.On{GetNameRootFromEventComponentType(eventComponentType)}Added();",
                        "        }",
                        "    }",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewDirtyJobStruct);
    }

    private static void GenerateEventSystemOnRemovedEventJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var eventComponentViewDirtyJobStruct = new StructModel($"NotifyRemove{eventComponentType.Name}Job<T>")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch where T : class, {GetRemovedInterfaceForEventComponentOfType(eventComponentType)}"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "EntityManager",
                    Name = "EntityManager",
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<RemovedComponentArrayData>",
                    Name = "DataTypeHandle",
                    Attributes = new List<AttributeModel> { new AttributeModel("ReadOnly") }
                },
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = "ComponentTypeHandle<T>",
                    Name = "ListenerTypeHandle"
                }
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        "var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);",
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                    
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    var listener = listenerAccessor[i];", 
                        "    for (int j = 0; j < data.Value.Length; j++)",
                        "    {",
                        $"        if (data.Value[j] == ComponentType.ReadWrite<{eventComponentType.Name}>().TypeIndex)",
                        "        {",
                        $"            listener.On{GetNameRootFromEventComponentType(eventComponentType)}Removed();",
                        "        }",
                        "    }",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewDirtyJobStruct);
    }         
         
    private static void GenerateEventSystemDirtyResetJobs(ITypeSymbol eventComponentType, ClassModel classModel)
    {
        var eventComponentViewCallbackJobStruct = new StructModel($"{eventComponentType.Name}ResetDirtyJob")
        {
            AccessModifier = AccessModifier.Private,
            Interfaces = new List<string>
            {
                $"IJobEntityBatch"
            },
            Fields = new List<Field>
            {
                new Field
                {
                    AccessModifier = AccessModifier.Public,
                    CustomDataType = $"ComponentTypeHandle<{eventComponentType.Name}>",
                    Name = $"DataTypeHandle",
                },
            },
            Methods = new List<Method>
            {
                new Method
                {
                    AccessModifier = AccessModifier.Public,
                    BuiltInDataType = BuiltInDataType.Void,
                    Parameters = new List<Parameter>
                    {
                        new Parameter("ArchetypeChunk", "batchInChunk"),
                        new Parameter(BuiltInDataType.Int, "batchIndex")
                    },
                    Name = "Execute",
                    BodyLines = new List<string>
                    {
                        $"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);",
                            
                        "for (int i = 0; i < batchInChunk.Count; i++)",
                        "{",
                        "    var data = dataArray[i];",
                        "    if (data.IsDirty)",
                        "    {",
                        $"        data.IsDirty = false;",
                        "    }",
                        "    dataArray[i] = data;",
                        "}",
                    }
                }
            }
        };
            
        classModel.NestedStructs.Add(eventComponentViewCallbackJobStruct);
    }

    private static void GenerateEventViewInterfaceFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentWithEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateEventViewInterfaceImplementation(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateEventViewInterfaceImplementation(ITypeSymbol classWithEventsAttr)
    {
        var file = new FileModel($"{classWithEventsAttr.Name}Event")
        {
            Header = FileHeader,
            Namespace = classWithEventsAttr.ContainingNamespace?.Name ?? "",
        };

        var classModel = new ClassModel(classWithEventsAttr.Name)
        {
            AccessModifier = AccessModifier.Public,
            SingleKeyWord = KeyWord.Partial,
            Interfaces = new List<string>()
        };

        //for each ComponentData that is listened by ViewClass's OnAddedEventView attribute, implement its respective interface in the ViewClass
        var addedEventViewAttr = classWithEventsAttr.GetCustomAttribute(OnAddedEventViewAttributeType);
        if (addedEventViewAttr != null)
        {
            var addedEventTargetedEcsTypes = addedEventViewAttr.GetFieldValueTypes("Types");
            foreach (var addedEventTargetedEcsType in addedEventTargetedEcsTypes)
            {
                classModel.Interfaces.Add(GetAddedInterfaceForEventComponentOfType(addedEventTargetedEcsType));
            }
        }

        //for each ComponentData that is listened by ViewClass's OnRemovedEventView attribute, implement its respective interface in the ViewClass
        var removedEventViewAttr = classWithEventsAttr.GetCustomAttribute(OnRemovedEventViewAttributeType);
        if (removedEventViewAttr != null)
        {
            var removedEventTargetedEcsTypes = removedEventViewAttr.GetFieldValueTypes("Types");
            foreach (var removedEventTargetedEcsType in removedEventTargetedEcsTypes)
            {
                classModel.Interfaces.Add(GetRemovedInterfaceForEventComponentOfType(removedEventTargetedEcsType));
            }
        }

        //for each ComponentData that is listened by ViewClass's OnDirtyEventView attribute, implement its respective interface in the ViewClass
        var dirtyEventViewAttr = classWithEventsAttr.GetCustomAttribute(OnDirtyEventViewAttributeType);
        if (dirtyEventViewAttr != null)
        {
            foreach (var dirtyEventTargetedEcsType in dirtyEventViewAttr.GetFieldValueTypes("Types"))
            {
                classModel.Interfaces.Add(GetDirtyInterfaceForEventComponentOfType(dirtyEventTargetedEcsType));
            }
        }

        file.Classes.Add(classModel);
        return file;
    }

    private static void GenerateReadWriteEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ReadWriteEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateReadWriteEcs(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateReadWriteEcs(ITypeSymbol classWithWriteToEcs)
    {
        var file = new FileModel($"{classWithWriteToEcs.Name}ReadWrite")
        {
            Header = FileHeader,
            Namespace = classWithWriteToEcs.ContainingNamespace?.Name ?? "",
        };

        var classModel = new ClassModel(classWithWriteToEcs.Name);
        classModel.AccessModifier = AccessModifier.Public;
        classModel.SingleKeyWord = KeyWord.Partial;

        classModel.Properties = new List<Property>();

        var wteAttribute = classWithWriteToEcs.GetCustomAttribute(ReadWriteEcsAttributeType, true);
        foreach (var toWriteToType in wteAttribute.GetFieldValueTypes("Types"))
        {
            var propertyModel = new Property(toWriteToType.Name, toWriteToType.Name)
            {
                AccessModifier = AccessModifier.Public,
                IsExpressBody = true,
                IsAutoImplemented = false,
                GetterBody = $"EntityManager.GetComponentData<{toWriteToType.Name}>(LinkedEntity)",
                SetterBody = "EntityManager.SetComponentData(LinkedEntity, value)"
            };
            classModel.Properties.Add(propertyModel);
        }

        file.Classes.Add(classModel);
        return file;
    }

    private static void GenerateHasComponentEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.HasComponentEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateHasComponentEcs(typeSymbol);

            context.AddSource(typeSymbol.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateHasComponentEcs(ITypeSymbol classWithHasComponentEcs)
    {
        var file = new FileModel($"{classWithHasComponentEcs.Name}HasComponent")
        {
            Header = FileHeader,
            Namespace = classWithHasComponentEcs.ContainingNamespace?.Name ?? "",
        };

        var classModel = new ClassModel(classWithHasComponentEcs.Name)
        {
            AccessModifier = AccessModifier.Public,
            SingleKeyWord = KeyWord.Partial,
            Properties = new List<Property>()
        };

        var hasCpAttribute = classWithHasComponentEcs.GetCustomAttribute(HasComponentEcsAttributeType, true);
        foreach (var hasCpTypes in hasCpAttribute.GetFieldValueTypes("Types"))
        {
            var propertyModel = new Property("bool", $"Has{hasCpTypes.Name}")
            {
                AccessModifier = AccessModifier.Public,
                IsExpressBody = true,
                IsAutoImplemented = false,
                GetterBody = $"EntityManager.HasComponent<{hasCpTypes.Name}>(LinkedEntity)",
            };
            classModel.Properties.Add(propertyModel);
        }

        file.Classes.Add(classModel);
        return file;
    }

    private static void GenerateNetMessageFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.NetworkMessageTypes)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var file = GenerateNetMessage(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateNetMessage(ITypeSymbol netMessageType)
    {
        var file = new FileModel(netMessageType.Name + "Gen")
        {
            UsingDirectives = new List<string>
            {
                "DOTSNET;",
                "Unity.Collections;",
                "System;"
            },
            Header = FileHeader,
            Namespace = netMessageType.ContainingNamespace?.Name ?? "",
            Structs = new List<StructModel>()
        };

        var netMessageStructModel = new StructModel(netMessageType.Name)
        {
            AccessModifier = AccessModifier.Public,
            SingleKeyWord = KeyWord.Partial,
            Interfaces = new List<string> { "NetworkMessage" },
            Constructors = new List<Constructor>()
        };

        var netMessageConstructor = new Constructor(netMessageType.Name)
        {
            AccessModifier = AccessModifier.Public,
            Parameters = netMessageType.GetFields().Select(f => new Parameter(f.Type.Name, f.Name.ToCamel())).ToList(),
            BodyLines = netMessageType.GetFields().Select(f => $"this.{f.Name} = {f.Name.ToCamel()};").ToList()
        };
        netMessageStructModel.Constructors.Add(netMessageConstructor);

        // SerializeModel
        var netMessageSerializeMethodModel = new Method(BuiltInDataType.Bool, "Serialize")
        {
            AccessModifier = AccessModifier.Public,
            Parameters = new List<Parameter> { new Parameter("ref NetworkWriter writer") },
            BodyLines = new List<string>()
        };

        var fields = netMessageType.GetFields().ToArray();
        var totalFieldsCount = fields.Length;
        if (totalFieldsCount == 0)
        {
            netMessageSerializeMethodModel.BodyLines.Add("return true;");
        }
        else
        {
            netMessageSerializeMethodModel.BodyLines.Add("return");

            for (var i = 0; i < totalFieldsCount; i++)
            {
                var fieldInfo = fields[i];
                if (!IsDotsnetType(fieldInfo.Type))
                {
                    throw new Exception($"Failed to find {fieldInfo.Type.Name}");
                }

                if (i == totalFieldsCount - 1)
                {
                    //last one
                    netMessageSerializeMethodModel.BodyLines.Add(
                        $"writer.Write{GetDotsnetTypeName(fieldInfo.Type)}({fieldInfo.Name});");
                }
                else
                {
                    netMessageSerializeMethodModel.BodyLines.Add(
                        $"writer.Write{GetDotsnetTypeName(fieldInfo.Type)}({fieldInfo.Name}) &&");
                }

            }
        }

        netMessageStructModel.Methods.Add(netMessageSerializeMethodModel);

        // DeserializeModel
        var netMessageDeserializeMethodModel = new Method(BuiltInDataType.Bool, "Deserialize")
        {
            AccessModifier = AccessModifier.Public,
            Parameters = new List<Parameter> { new Parameter("ref NetworkReader reader") },
            BodyLines = new List<string>()
        };

        totalFieldsCount = fields.Length;
        if (totalFieldsCount == 0)
        {
            netMessageDeserializeMethodModel.BodyLines.Add("return true;");
        }
        else
        {
            netMessageDeserializeMethodModel.BodyLines.Add("return");

            for (var i = 0; i < totalFieldsCount; i++)
            {
                var fieldInfo = fields[i];
                if (!IsDotsnetType(fieldInfo.Type))
                {
                    throw new Exception($"Failed to find {fieldInfo.Type.Name}");
                }

                if (i == totalFieldsCount - 1)
                {
                    // last one
                    netMessageDeserializeMethodModel.BodyLines.Add(
                        $"reader.Read{GetDotsnetTypeName(fieldInfo.Type)}(out {fieldInfo.Name});");
                }
                else
                {
                    netMessageDeserializeMethodModel.BodyLines.Add(
                        $"reader.Read{GetDotsnetTypeName(fieldInfo.Type)}(out {fieldInfo.Name}) &&");
                }

            }
        }

        netMessageStructModel.Methods.Add(netMessageDeserializeMethodModel);

        file.Structs.Add(netMessageStructModel);
        return file;
    }

    private static void GenerateNetworkComponentFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            if (!typeSymbol.HasAttribute(CodeGenNetComponentAttributeType))
            {
                continue;
            }

            var file = GenerateNetworkComponent(typeSymbol);

            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static FileModel GenerateNetworkComponent(ITypeSymbol eventComponentDataType)
    {
        var file = new FileModel(eventComponentDataType.Name + "Serializer")
        {
            UsingDirectives = new List<string>
            {
                "Unity.Jobs;"
            },
            Header = FileHeader,
            Namespace = eventComponentDataType.ContainingNamespace?.Name ?? "",
        };

        file.Classes.Add(GenerateNetworkComponentSerializerClassModel(eventComponentDataType));
        return file;
    }

    private static ClassModel GenerateNetworkComponentSerializerClassModel(ITypeSymbol eventComponentDataType)
    {
        var networkComponentSerializerClassModel = new ClassModel($"{eventComponentDataType.Name}Serializer")
        {
            BaseClass = $"DOTSNetworkComponentSerializer<{eventComponentDataType.Name}>",
            AccessModifier = AccessModifier.Public,
            Attributes = new List<AttributeModel>
            {
                new($"assembly: RegisterGenericJobType(typeof(DOTSNetworkComponentSerializer<{eventComponentDataType.Name}>.NetworkComponentSerializerJob))"),
                new($"assembly: RegisterGenericJobType(typeof(DOTSNetworkComponentSerializer<{eventComponentDataType.Name}>.NetworkComponentDeserializerJob))")
            }
        };

        return networkComponentSerializerClassModel;
    }

    private static IEnumerable<ITypeSymbol> ExtractTypesFromAttribute(AttributeSyntax attributeSyntax, SemanticModel model)
    {
        if (attributeSyntax == null || attributeSyntax.ArgumentList == null)
        {
            return Array.Empty<ITypeSymbol>();
        }

        var typeOfExpressions = attributeSyntax.ArgumentList.Arguments.Select(_ => _.Expression).OfType<TypeOfExpressionSyntax>();
        var validTypes = typeOfExpressions.Select(typeOfExpression => model.GetTypeInfo(typeOfExpression.Type)).Where(_ => _.Type != null).Select(_ => _.Type!);
        return validTypes;
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private static string LowercaseName(string identifier)
    {
        return identifier.Substring(0, 1).ToLowerInvariant() + identifier.Substring(1);
    }

    /// <summary>
    /// Helper to get the name of the DirtyEvent interface for certain ComponentData, used for partial ViewClass generation
    /// </summary>
    /// <param name="eventComponentType">Component type for which get name of corresponding change listener.</param>
    /// <returns>Name of the change listener interface for the component.</returns>
    private static string GetDirtyInterfaceForEventComponentOfType(ITypeSymbol eventComponentType)
    {
        return $"I{GetNameRootFromEventComponentType(eventComponentType)}Listener";
    }

    /// <summary>
    /// Helper to get the name of the AddedEvent interface for certain ComponentData, used for partial ViewClass generation
    /// </summary>
    /// <param name="eventComponentType">Component type for which get name of corresponding add listener.</param>
    /// <returns>Name of the add listener interface for the component.</returns>
    private static string GetAddedInterfaceForEventComponentOfType(ITypeSymbol eventComponentType)
    {
        return $"I{GetNameRootFromEventComponentType(eventComponentType)}AddedListener";
    }

    /// <summary>
    /// Helper to get the name of the RemovedEvent interface for certain ComponentData
    /// </summary>
    /// <param name="eventComponentType">Component type for which get name of corresponding remove listener.</param>
    /// <returns>Name of the remove listener interface for the component.</returns>
    private static string GetRemovedInterfaceForEventComponentOfType(ITypeSymbol eventComponentType)
    {
        return $"I{GetNameRootFromEventComponentType(eventComponentType)}RemovedListener";
    }

    /// <summary>
    /// ComponentData struct usually suffix with Tag or Data indicating what they are used for.
    /// In order to generate related system or partial structs, those suffix are stripped in order to get the name of the ComponentData struct.
    /// </summary>
    /// <param name="eventComponentType"></param>
    /// <returns></returns>
    private static string GetNameRootFromEventComponentType(ITypeSymbol eventComponentType)
    {
        var typeName = eventComponentType.Name;
        if (typeName.EndsWith("Tag"))
        {
            return typeName.Substring(0, typeName.Length - 3);
        }
        else if (typeName.EndsWith("Data"))
        {
            return typeName.Substring(0, typeName.Length - 4);
        }
        else
        {
            return typeName;
        }
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<StructDeclarationSyntax> ComponentDirtyEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ComponentWithEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ReadWriteEcs { get; } = new();
        public List<ClassDeclarationSyntax> HasComponentEcs { get; } = new();
        public List<StructDeclarationSyntax> NetworkMessageTypes { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context is StructDeclarationSyntax structDeclarationSyntax
                && structDeclarationSyntax.AttributeLists.Count > 0)
            {
                var componentDirtyEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentDirtyEventAttributeType);
                var componentRemovedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentRemovedEventAttributeType);
                var componentAddedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(ComponentAddedEventAttributeType);
                var codeGenNetComponentAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(CodeGenNetComponentAttributeType);
                if (componentDirtyEventAttribute != null || codeGenNetComponentAttribute != null
                    || componentRemovedEventAttribute != null || componentAddedEventAttribute != null)
                {
                    this.ComponentDirtyEventStructs.Add(structDeclarationSyntax);
                }

                var codeGenNetMessageAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(CodeGenNetMessageAttributeType);
                if (codeGenNetMessageAttribute != null)
                {
                    this.NetworkMessageTypes.Add(structDeclarationSyntax);
                }
            }

            if (context is ClassDeclarationSyntax classtDeclarationSyntax
                && classtDeclarationSyntax.AttributeLists.Count > 0)
            {
                var onAddedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute(OnAddedEventViewAttributeType);
                var onRemovedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute(OnRemovedEventViewAttributeType);
                var onDirtyEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute(OnDirtyEventViewAttributeType);
                if (onAddedEventViewAttribute != null || onRemovedEventViewAttribute != null || onDirtyEventViewAttribute != null)
                {
                    this.ComponentWithEventStructs.Add(classtDeclarationSyntax);
                }

                var readWriteEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("ReadWriteEcs");
                if (readWriteEcsAttribute != null)
                {
                    this.ReadWriteEcs.Add(classtDeclarationSyntax);
                }

                var hasComponentEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("HasComponentEcs");
                if (hasComponentEcsAttribute != null)
                {
                    this.HasComponentEcs.Add(classtDeclarationSyntax);
                }
            }
        }
    }
}
