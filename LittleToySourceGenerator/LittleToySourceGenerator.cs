using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace LittleToySourceGenerator;

[Generator]
public class Generator : ISourceGenerator
{
    public bool GenerateEventData { get; set; } = true;
    public bool GenerateEventSystem { get; set; } = true;
    public bool GenerateEventViewInterface { get; set; } = true;
    public bool GenerateReadWriteEcs { get; set; } = true;

    public void DisableAllGeneration()
    {
        GenerateEventData = false;
        GenerateEventSystem = false;
        GenerateEventViewInterface = false;
        GenerateReadWriteEcs = false;
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        if (GenerateEventData)
        {
            GenerateEventDataFiles(context, receiver);
        }

        if (GenerateEventSystem)
        {
            GenerateEventSystemFiles(context, receiver);
        }

        if (GenerateEventViewInterface)
        {
            GenerateEventViewInterfaceFiles(context, receiver);
        }

        if (GenerateReadWriteEcs)
        {
            GenerateReadWriteEcsFiles(context, receiver);
            GenerateHasComponentEcsFiles(context, receiver);
        }
    }

    private static void GenerateEventDataFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            if (typeSymbol.HasAttribute("ComponentDirtyEvent"))
            {
                var fields = typeSymbol.GetMembers().OfType<IFieldSymbol>()
                    .Where(field => field.HasAttribute("MarkDirty"));
                GenerateEventStructModel(typeSymbol, builder, fields);
                builder.AppendLine();
                GenerateComponentDirtyEventInterfaceModel(typeSymbol, builder, fields);
            }

            if (typeSymbol.HasAttribute("ComponentRemovedEvent"))
            {
                GenerateComponentRemovedEventInterfaceModel(typeSymbol, builder);
            }

            if (typeSymbol.HasAttribute("ComponentAddedEvent"))
            {
                GenerateComponentAddedEventInterfaceModel(typeSymbol, builder);
            }

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }


            context.AddSource(typeSymbol.Name + "EventData", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateEventSystemFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            builder.AppendLine($"[UpdateBefore(typeof(CleanUpAddedRemovedEventSystem))]");
            builder.AppendLine($"[ClientWorld]");
            builder.AppendLine($"[UpdateInGroup(typeof(SimulationSystemGroup), OrderLast = true)]");
            builder.AppendLine($"public partial class {GetNameRootFromEventComponentType(typeSymbol)}EventSystem : SystemBase");
            builder.OpenBraces();

            List<ClassDeclarationSyntax> classCandidates = receiver.ComponentWithEventStructs;
            var dirtyEventViewTypes = GetDirtyTypes(model, typeSymbol, classCandidates, "OnDirtyEventView");

            // Fields
            foreach (var eventViewType in dirtyEventViewTypes)
            {
                builder.AppendLine($"private EntityQuery _entityWith{eventViewType.Name}And{typeSymbol.Name}Query;");
            }

            builder.AppendLine($"private EntityQuery _entityWith{typeSymbol.Name}Query;");
            builder.AppendLine($"private ComponentTypeHandle<{typeSymbol.Name}> _{typeSymbol.Name}ROComponentTypeHandle;");
            builder.AppendLine($"private ComponentTypeHandle<{typeSymbol.Name}> _{typeSymbol.Name}RWComponentTypeHandle;");
            builder.AppendLine();

            // OnCreate
            builder.AppendLine($"protected override void OnCreate()");
            builder.OpenBraces();
            builder.AppendLine($"base.OnCreate();");
            foreach (var eventViewType in dirtyEventViewTypes)
            {
                builder.AppendLine($"_entityWith{eventViewType.Name}And{typeSymbol.Name}Query = GetEntityQuery(new EntityQueryDesc");
                builder.OpenBraces();
                builder.AppendLine($"All = new []");
                builder.OpenBraces();
                builder.AppendLine($"ComponentType.ReadWrite<{eventViewType.Name}>(),");
                builder.AppendLine($"ComponentType.ReadOnly<{typeSymbol.Name}>(),");
                builder.CloseBraces();
                builder.CloseBraces(");");
                builder.AppendLine($"_entityWith{eventViewType.Name}And{typeSymbol.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{typeSymbol.Name}>());");
                builder.AppendLine();
            }

            builder.AppendLine($"_entityWith{typeSymbol.Name}Query = GetEntityQuery(new EntityQueryDesc");
            builder.OpenBraces();
            builder.AppendLine($"All = new []");
            builder.OpenBraces();
            builder.AppendLine($"ComponentType.ReadWrite<{typeSymbol.Name}>(),");
            builder.CloseBraces();
            builder.CloseBraces(");");
            builder.AppendLine($"_entityWith{typeSymbol.Name}Query.SetChangedVersionFilter(ComponentType.ReadOnly<{typeSymbol.Name}>());");
            builder.AppendLine($"_{typeSymbol.Name}ROComponentTypeHandle = GetComponentTypeHandle<{typeSymbol.Name}>(true);");
            builder.AppendLine($"_{typeSymbol.Name}RWComponentTypeHandle = GetComponentTypeHandle<{typeSymbol.Name}>(false);");
            builder.CloseBraces();
            builder.AppendLine();

            // OnUpdate
            builder.AppendLine($"protected override void OnUpdate()");
            builder.OpenBraces();
            foreach (var eventViewType in dirtyEventViewTypes)
            {
                builder.AppendLine($"_{typeSymbol.Name}ROComponentTypeHandle.Update(this);");
                builder.AppendLine($"var notify{eventViewType.Name}{typeSymbol.Name}DirtyJob = new Notify{typeSymbol.Name}DirtyJob<{eventViewType.Name}>");
                builder.OpenBraces();
                builder.AppendLine($"EntityManager = this.EntityManager,");
                builder.AppendLine($"DataTypeHandle = _{typeSymbol.Name}ROComponentTypeHandle,");
                builder.AppendLine($"ListenerTypeHandle = EntityManager.GetComponentTypeHandle<{eventViewType.Name}>(false)");
                builder.CloseBraces(";");
                builder.AppendLine($"CompleteDependency();");
                builder.AppendLine($"JobEntityBatchExtensions.RunWithoutJobs(ref notify{eventViewType.Name}{typeSymbol.Name}DirtyJob, _entityWith{eventViewType.Name}And{typeSymbol.Name}Query);");
                builder.AppendLine();
            }

            builder.AppendLine($"_{typeSymbol.Name}RWComponentTypeHandle.Update(this);");
            builder.AppendLine($"var job{typeSymbol.Name}ResetDirty = new {typeSymbol.Name}ResetDirtyJob");
            builder.OpenBraces();
            builder.AppendLine($"DataTypeHandle = _{typeSymbol.Name}RWComponentTypeHandle,");
            builder.CloseBraces(";");
            builder.AppendLine($"CompleteDependency();");
            builder.AppendLine($"JobEntityBatchExtensions.RunWithoutJobs(ref job{typeSymbol.Name}ResetDirty, _entityWith{typeSymbol.Name}Query);");
            builder.CloseBraces();
            builder.AppendLine();

            GenerateNotifyDirtyJob();
            builder.AppendLine();
            GenerateResetDirtyJob();

            builder.CloseBraces();
            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "EventSystem", SourceText.From(builder.ToString(), Encoding.UTF8));

            void GenerateNotifyDirtyJob()
            {
                builder.AppendLine($"private struct Notify{typeSymbol.Name}DirtyJob<T> : IJobEntityBatch where T : class, IPosition3Listener");
                builder.OpenBraces();
                builder.AppendLine($"public EntityManager EntityManager;");
                builder.AppendLine($"public ComponentTypeHandle<{typeSymbol.Name}> DataTypeHandle;");
                builder.AppendLine($"public ComponentTypeHandle<T> ListenerTypeHandle;");
                builder.AppendLine();
                builder.AppendLine($"public void Execute(ArchetypeChunk batchInChunk, int batchIndex)");
                builder.OpenBraces();
                builder.AppendLine($"var listenerAccessor = batchInChunk.GetManagedComponentAccessor(ListenerTypeHandle, EntityManager);");
                builder.AppendLine($"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);");
                builder.AppendLine($"for (int i = 0; i < batchInChunk.Count; i++)");
                builder.OpenBraces();
                builder.AppendLine($"var data = dataArray[i];");
                builder.AppendLine($"var listener = listenerAccessor[i];");
                builder.AppendLine($"if (data.IsDirty && listener != null)");
                builder.OpenBraces();
                builder.AppendLine($"listener.On{GetNameRootFromEventComponentType(typeSymbol)}Changed(data.Value);");
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces(); // Execute
                builder.CloseBraces(); // struct
            }
            void GenerateResetDirtyJob()
            {
                builder.AppendLine($"private struct {typeSymbol.Name}ResetDirtyJob : IJobEntityBatch");
                builder.OpenBraces();
                builder.AppendLine($"public ComponentTypeHandle<{typeSymbol.Name}> DataTypeHandle;");
                builder.AppendLine();
                builder.AppendLine($"public void Execute(ArchetypeChunk batchInChunk, int batchIndex)");
                builder.OpenBraces();
                builder.AppendLine($"var dataArray = batchInChunk.GetNativeArray(DataTypeHandle);");
                builder.AppendLine($"for (int i = 0; i < batchInChunk.Count; i++)");
                builder.OpenBraces();
                builder.AppendLine($"var data = dataArray[i];");
                builder.AppendLine($"if (data.IsDirty)");
                builder.OpenBraces();
                builder.AppendLine($"data.IsDirty = false;");
                builder.CloseBraces();
                builder.AppendLine($"dataArray[i] = data;");
                builder.CloseBraces();
                builder.CloseBraces();
                builder.CloseBraces();
            }
        }
    }

    private static List<ITypeSymbol> GetDirtyTypes(SemanticModel model, ITypeSymbol typeSymbol, List<ClassDeclarationSyntax> classCandidates, string SearchAttributeName)
    {
        return classCandidates.Where(eventType =>
        {
            var onDirtyEventViewAttribute = eventType.AttributeLists.FindAttribute(SearchAttributeName);
            var dirtyViewTypes = ExtractTypesFromAttribute(onDirtyEventViewAttribute, model);
            return dirtyViewTypes.Contains(typeSymbol);
        }).Select(eventType =>
        {
            ITypeSymbol eventTypeSymbol = (ITypeSymbol)model.GetDeclaredSymbol(eventType);
            return eventTypeSymbol;
        }).ToList();
    }

    private static void GenerateEventViewInterfaceFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ComponentWithEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            var onDirtyEventViewAttribute = type.AttributeLists.FindAttribute("OnDirtyEventView");
            var dirtyViewTypes = ExtractTypesFromAttribute(onDirtyEventViewAttribute, model).Select(typeInfo =>
            {
                return $"I{GetNameRootFromEventComponentType(typeInfo)}Listener";
            });
            var onAddedEventViewAttribute = type.AttributeLists.FindAttribute("OnAddedEventView");
            var addedViewTypes = ExtractTypesFromAttribute(onAddedEventViewAttribute, model).Select(typeInfo =>
            {
                return $"I{GetNameRootFromEventComponentType(typeInfo)}AddedListener";
            });
            var onRemovedEventViewAttribute = type.AttributeLists.FindAttribute("OnRemovedEventView");
            var removedViewTypes = ExtractTypesFromAttribute(onRemovedEventViewAttribute, model).Select(typeInfo =>
            {
                return $"I{GetNameRootFromEventComponentType(typeInfo)}RemovedListener";
            });
            string interfacesList = string.Join(", ", dirtyViewTypes.Union(addedViewTypes).Union(removedViewTypes));
            var name = typeSymbol.Name;
            builder.AppendLine($@"public partial class {name} : {interfacesList}");
            builder.OpenBraces();
            builder.CloseBraces();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "Event", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateReadWriteEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.ReadWriteEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            var readWriteEcsAttribute = type.AttributeLists.FindAttribute("ReadWriteEcs");
            var readWriteEcsTypes = ExtractTypesFromAttribute(readWriteEcsAttribute, model);
            var name = typeSymbol.Name;
            builder.AppendLine($@"public partial class {name}");
            builder.OpenBraces();
            foreach (var readWriteEcsProperty in readWriteEcsTypes)
            {
                builder.AppendLine($"public {readWriteEcsProperty.Name} {readWriteEcsProperty.Name}");
                builder.OpenBraces();
                builder.AppendLine($"get => EntityManager.GetComponentData<{readWriteEcsProperty.Name}>(LinkedEntity);");
                builder.AppendLine($"set => EntityManager.SetComponentData(LinkedEntity, value);");
                builder.CloseBraces();
            }
            builder.CloseBraces();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "ReadWrite", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateHasComponentEcsFiles(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var type in receiver.HasComponentEcs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            var hasComponentEcsAttribute = type.AttributeLists.FindAttribute("HasComponentEcs");
            var hasComponentEcsTypes = ExtractTypesFromAttribute(hasComponentEcsAttribute, model);
            var name = typeSymbol.Name;
            builder.AppendLine($@"public partial class {name}");
            builder.OpenBraces();
            foreach (var readWriteEcsProperty in hasComponentEcsTypes)
            {
                builder.AppendLine($"public bool Has{readWriteEcsProperty.Name} => EntityManager.HasComponent<{readWriteEcsProperty.Name}>(LinkedEntity);");
            }
            builder.CloseBraces();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }

            context.AddSource(typeSymbol.Name + "HasComponent", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static IEnumerable<ITypeSymbol> ExtractTypesFromAttribute(AttributeSyntax attributeSyntax, SemanticModel model)
    {
        if (attributeSyntax == null)
        {
            return Array.Empty<ITypeSymbol>();
        }

        var typeOfExpressions = attributeSyntax.ArgumentList.Arguments.Select(_ => _.Expression).OfType<TypeOfExpressionSyntax>();
        var validTypes = typeOfExpressions.Select(typeOfExpression => model.GetTypeInfo(typeOfExpression.Type)).Where(_ => _.Type != null).Select(_ => _.Type!);
        return validTypes;
    }

    private static void GenerateEventStructModel(ITypeSymbol typeSymbol, IndentedStringBuilder builder, IEnumerable<IFieldSymbol> fields)
    {
        var name = typeSymbol.Name;
        builder.AppendLine($@"public partial struct {name}");
        builder.OpenBraces();
        builder.AppendLine($@"public bool IsDirty {{ get; set; }}");
        var parameters = string.Join(", ", fields.Select(f => $"{f.Type.ToDisplayString()} {LowercaseName(f.Name)}"));
        builder.AppendLine($@"public {typeSymbol.ToDisplayString()} Update({parameters})");
        builder.OpenBraces();
        var comparison = string.Join(" && ", fields.Select(f => $"{f.Name}.Equals({LowercaseName(f.Name)})"));
        builder.AppendLine($@"if({comparison}) return this;");
        builder.AppendLine();
        builder.AppendLine("IsDirty = true;");
        foreach (var field in fields)
        {
            builder.AppendLine($"{field.Name} = {LowercaseName(field.Name)};");
        }

        builder.AppendLine();
        builder.AppendLine("return this;");
        builder.CloseBraces();

        builder.CloseBraces();
    }

    private static void GenerateComponentDirtyEventInterfaceModel(ITypeSymbol typeSymbol, IndentedStringBuilder builder, IEnumerable<IFieldSymbol> fields)
    {
        var nameRoot = GetNameRootFromEventComponentType(typeSymbol);
        builder.AppendLine($@"public interface I{nameRoot}Listener");
        builder.OpenBraces();
        var parameters = string.Join(", ", fields.Select(f => $"{f.Type.ToDisplayString()} {LowercaseName(f.Name)}"));
        builder.AppendLine($@"public void On{nameRoot}Changed({parameters});");
        builder.CloseBraces();
    }

    private static void GenerateComponentRemovedEventInterfaceModel(ITypeSymbol typeSymbol, IndentedStringBuilder builder)
    {
        var nameRoot = GetNameRootFromEventComponentType(typeSymbol);
        builder.AppendLine($@"public interface I{nameRoot}RemovedListener");
        builder.OpenBraces();
        builder.AppendLine($@"public void On{nameRoot}Removed();");
        builder.CloseBraces();
    }

    private static void GenerateComponentAddedEventInterfaceModel(ITypeSymbol typeSymbol, IndentedStringBuilder builder)
    {
        var nameRoot = GetNameRootFromEventComponentType(typeSymbol);
        builder.AppendLine($@"public interface I{nameRoot}AddedListener");
        builder.OpenBraces();
        builder.AppendLine($@"public void On{nameRoot}Added();");
        builder.CloseBraces();
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private static string LowercaseName(string identifier)
    {
        return identifier.Substring(0, 1).ToLowerInvariant() + identifier.Substring(1);
    }

    /// <summary>
    /// ComponentData struct usually suffix with Tag or Data indicating what they are used for.
    /// In order to generate related system or partial structs, those suffix are stripped in order to get the name of the ComponentData struct.
    /// </summary>
    /// <param name="eventComponentType"></param>
    /// <returns></returns>
    private static string GetNameRootFromEventComponentType(ITypeSymbol eventComponentType)
    {
        var typeName = eventComponentType.Name;
        if (typeName.EndsWith("Tag"))
        {
            return typeName.Substring(0, typeName.Length - 3);
        }
        else if (typeName.EndsWith("Data"))
        {
            return typeName.Substring(0, typeName.Length - 4);
        }
        else
        {
            return typeName;
        }
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<StructDeclarationSyntax> ComponentDirtyEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ComponentWithEventStructs { get; } = new();
        public List<ClassDeclarationSyntax> ReadWriteEcs { get; } = new();
        public List<ClassDeclarationSyntax> HasComponentEcs { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context is StructDeclarationSyntax structDeclarationSyntax
                && structDeclarationSyntax.AttributeLists.Count > 0)
            {
                var componentDirtyEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute("ComponentDirtyEvent");
                var componentRemovedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute("ComponentRemovedEvent");
                var componentAddedEventAttribute = structDeclarationSyntax.AttributeLists.FindAttribute("ComponentAddedEvent");
                if (componentDirtyEventAttribute != null || componentRemovedEventAttribute != null || componentAddedEventAttribute != null)
                {
                    this.ComponentDirtyEventStructs.Add(structDeclarationSyntax);
                }
            }

            if (context is ClassDeclarationSyntax classtDeclarationSyntax
                && classtDeclarationSyntax.AttributeLists.Count > 0)
            {
                var onAddedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("OnAddedEventView");
                var onRemovedEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("OnRemovedEventView");
                var onDirtyEventViewAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("OnDirtyEventView");
                if (onAddedEventViewAttribute != null || onRemovedEventViewAttribute != null || onDirtyEventViewAttribute != null)
                {
                    this.ComponentWithEventStructs.Add(classtDeclarationSyntax);
                }

                var readWriteEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("ReadWriteEcs");
                if (readWriteEcsAttribute != null)
                {
                    this.ReadWriteEcs.Add(classtDeclarationSyntax);
                }

                var hasComponentEcsAttribute = classtDeclarationSyntax.AttributeLists.FindAttribute("HasComponentEcs");
                if (hasComponentEcsAttribute != null)
                {
                    this.HasComponentEcs.Add(classtDeclarationSyntax);
                }
            }
        }
    }
}
