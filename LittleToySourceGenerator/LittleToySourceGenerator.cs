using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LittleToySourceGenerator;

[Generator]
public class Generator : ISourceGenerator
{
    public bool GenerateEventData { get; set; } = true;

    public void DisableAllGeneration()
    {
        GenerateEventData = false;
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        foreach (var (type, attr) in receiver.ComponentDirtyEventStructs)
        {
            var model = context.Compilation.GetSemanticModel(type.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(type) as ITypeSymbol;
            var name = typeSymbol.Name;


            var builder = new IndentedStringBuilder(
            @"// <auto-generated>
// Code generated by LittleToy Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
");
            builder.AppendLine("using System;");
            builder.AppendLine("using Unity.Entities;");
            builder.AppendLine("using Unity.Mathematics;");
            builder.AppendLine("using Plugins.basegame.Events;");
            builder.AppendLine("using DOTSNET;");
            builder.AppendLine();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.AppendLine($@"namespace {typeSymbol.ContainingNamespace.ToDisplayString()}");
                builder.OpenBraces();
            }

            var nameRoot = GetNameRootFromEventComponentType(typeSymbol);
            builder.AppendLine($@"public partial struct {name}");
            builder.OpenBraces();
            builder.AppendLine($@"public bool IsDirty {{ get; set; }}");
            var fields = typeSymbol.GetMembers().OfType<IFieldSymbol>();
            var parameters = string.Join(", ", fields.Select(f => $"{f.Type.ToDisplayString()} {LowercaseName(f.Name)}"));// "float3 value";
            builder.AppendLine($@"public {typeSymbol.ToDisplayString()} Update({parameters})");
            builder.OpenBraces();
            var comparison = string.Join("\r\n&& ", fields.Select(f => $"{f.Name}.Equals({LowercaseName(f.Name)})"));
            builder.AppendLine($@"if({comparison}) return this;");
            builder.AppendLine();
            builder.AppendLine("IsDirty = true;");
            foreach (var field in fields)
            {
                builder.AppendLine($"{field.Name} = {LowercaseName(field.Name)};");
            }

            builder.AppendLine();
            builder.AppendLine("return this;");
            builder.CloseBraces();

            builder.CloseBraces();

            builder.AppendLine();
            builder.AppendLine($@"public interface I{nameRoot}Listener");
            builder.OpenBraces();
            builder.AppendLine($@"public void OnPosition3Changed({parameters});");
            builder.CloseBraces();

            if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.CloseBraces();
            }


            context.AddSource(name + "EventData", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private static string LowercaseName(string identifier)
    {
        return identifier.Substring(0, 1).ToLowerInvariant() + identifier.Substring(1);
    }

    /// <summary>
    /// ComponentData struct usually suffix with Tag or Data indicating what they are used for.
    /// In order to generate related system or partial structs, those suffix are stripped in order to get the name of the ComponentData struct.
    /// </summary>
    /// <param name="eventComponentType"></param>
    /// <returns></returns>
    private static string GetNameRootFromEventComponentType(ITypeSymbol eventComponentType)
    {
        var typeName = eventComponentType.Name;
        if (typeName.EndsWith("Tag"))
        {
            return typeName.Substring(0, typeName.Length - 3);
        }
        else if (typeName.EndsWith("Data"))
        {
            return typeName.Substring(0, typeName.Length - 4);
        }
        else
        {
            return typeName;
        }
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<(StructDeclarationSyntax, AttributeSyntax)> ComponentDirtyEventStructs { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode context)
        {
            // any field with at least one attribute is a candidate for property generation
            if (context is StructDeclarationSyntax structDeclarationSyntax
                && structDeclarationSyntax.AttributeLists.Count > 0)
            {
                var componentDirtyEventAttribute = FindAttribute("ComponentDirtyEvent", structDeclarationSyntax.AttributeLists);
                if (componentDirtyEventAttribute != null)
                {
                    this.ComponentDirtyEventStructs.Add((structDeclarationSyntax, componentDirtyEventAttribute));
                }
            }
        }

        private static AttributeSyntax FindAttribute(string searchAttributeName, SyntaxList<AttributeListSyntax> attributeLists)
        {
            return attributeLists.SelectMany(_ => _.Attributes).FirstOrDefault(a => a.Name.ToFullString().Contains(searchAttributeName));
        }
    }
}
