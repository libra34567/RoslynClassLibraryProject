namespace LittleToyZenjectify;

using CsCodeGenerator;
using CsCodeGenerator.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

[Generator]
public class Generator : ISourceGenerator
{
    private const string FileHeader = @"// <auto-generated>
// Code generated by LittleToy Zenjectify Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591
#if UNITY_EDITOR
using UnityEditor;
#endif";

    private const string AssetDatabaseExtensionSourceCode = @"// <auto-generated>
// Code generated by LittleToy Zenjectify Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
using System.Collections.Generic;
using System.IO;
using System.Linq;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

namespace UnityEditor
{
#if UNITY_EDITOR
    internal class AssetDatabaseEx
    {
        /// <summary>Gets an array of assets of type T at a given path. This path is relative to /Assets.</summary>
        /// <returns>An array of assets of type T.</returns>
        /// <param name=""path"">The file path relative to /Assets/.</param>
        public static List<T> GetAssetsAtPath<T>(string path) where T : UnityEngine.Object
        {
            var returnList = new List<T>();

            //get the contents of the folder's and it's subfolders full path (excluding any meta files) sorted alphabetically
            IEnumerable<string> fullpaths = Directory.GetFiles($""{Application.dataPath}/{path}"", ""*.*"", SearchOption.AllDirectories)
                .Where(x => !x.EndsWith("".meta"")).OrderBy(s => s);
            //loop through the folder contents
            foreach (var fullPath in fullpaths)
            {
                //determine a path starting with Assets
                var assetPath = fullPath.Replace(Application.dataPath, ""Assets"");
                //load the asset at this relative path
                UnityEngine.Object obj = AssetDatabase.LoadAssetAtPath<T>(assetPath);
                //and add it to the list if it is of type T
                if(obj is T)
                {
                    returnList.Add(obj as T);
                }
            }
                
            return returnList;
        }

        public static T GetSingleAssetsAtPath<T>(string path = null) where T : UnityEngine.Object
        {
            var candidates = GetAssetsAtPath<T>(path);
            if (candidates.Count > 1)
            {
                Debug.Log($""There more assets of type {typeof(T).FullName} found, selecting first. This search maybe undeterminate."");
            }

            return candidates.FirstOrDefault();
        }
    }
#endif
}
";

    private const string ZenGenAttributeType = "ZenGen";
    private static readonly AttributeModel RequiredInPrefabInstancesAttribute = new AttributeModel("RequiredInPrefabInstances");
    private static readonly AttributeModel SceneObjectsOnlyAttribute = new AttributeModel("SceneObjectsOnly");
    private static readonly AttributeModel AssetsOnlyAttribute = new AttributeModel("AssetsOnly");
    private static readonly AttributeModel SerializeFieldAttribute = new AttributeModel("SerializeField");

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        context.AddSource("AssetDatabaseExtension.cs", SourceText.From(AssetDatabaseExtensionSourceCode, Encoding.UTF8));
        var serviceDescriptors = GetServiceDescriptors(context, receiver).ToList();
        foreach (var installerServices in serviceDescriptors.GroupBy(_ => new { _.TargetInstallerNamespace, _.TargetInstallerName }))
        {
            string installerName = installerServices.Key.TargetInstallerName;
            string installerNamespace = installerServices.Key.TargetInstallerNamespace;
            if (!installerName.EndsWith("Installer"))
            {
                installerName += "Installer";
            }

            var file = CreateInstallerFile(installerName, installerNamespace, installerServices);
            context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
        }
    }

    private static IEnumerable<ServiceDescriptor> GetServiceDescriptors(GeneratorExecutionContext context, SyntaxReceiver receiver)
    {
        foreach (var _ in receiver.ServiceCandidates)
        {
            var semanticModel = context.Compilation.GetSemanticModel(_.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(_);
            if (_ is null)
            {
                continue;
            }

            if (IsValidServiceClass(typeSymbol))
            {
                var serviceDescriptor = GetServiceDescriptor(typeSymbol);
                var candidateTypes = context.Compilation.GetSymbolsWithName(_ => _ == serviceDescriptor.TargetInstallerName, SymbolFilter.Type).ToList();
                var candidate = candidateTypes.FirstOrDefault();
                serviceDescriptor.TargetInstallerNamespace = candidate?.ContainingNamespace.IsGlobalNamespace == true ? null : candidate?.ContainingNamespace?.ToDisplayString();
                yield return serviceDescriptor;
            }
        }
    }

    private static FileModel CreateInstallerFile(string installerName, string installerNamespace, IEnumerable<ServiceDescriptor> services)
    {
        var file = new FileModel(installerName)
        {
            UsingDirectives = new List<string>
            {
                "System.Collections.Generic;",
                "Sirenix.OdinInspector;",
                "UnityEngine;",
                "Zenject;",
            },
            Header = FileHeader,
        };

        var monoClassesWithSceneObjInstance = services.Where(s => s.InjectionMethod == InjectionMethod.MonoClassWithSceneObjInstance).ToList();
        var monoClassesWithAssetInstance = services.Where(s => s.InjectionMethod == InjectionMethod.MonoClassWithAssetInstance).ToList();
        var classesWithoutInstance = services.Where(s => s.InjectionMethod == InjectionMethod.ClassWithoutInstance).ToList();
        var prefabs = services.Where(s => s.InjectionMethod == InjectionMethod.Prefab).ToList();
        var signals = services.Where(s => s.InjectionMethod == InjectionMethod.Signal).ToList();

        var classModel = new ClassModel(installerName)
        {
            BaseClass = "MonoInstaller",
            KeyWords = new() { KeyWord.Partial },
            Namespace = installerNamespace,
            Attributes = new() {
                new AttributeModel($"AddComponentMenu(\"Installers/{installerName}\")"),
                new AttributeModel("DisallowMultipleComponent")
            }
        };
        foreach (var service in monoClassesWithSceneObjInstance)
        {
            classModel.Fields.Add(new Field()
            {
                AccessModifier = AccessModifier.Private,
                Attributes = new () { RequiredInPrefabInstancesAttribute, SceneObjectsOnlyAttribute, SerializeFieldAttribute },
                Name = service.ServiceType.Name.LowerFirst(),
                CustomDataType = service.ServiceType.ToDisplayString(),
            });
        }

        foreach (var service in monoClassesWithAssetInstance)
        {
            classModel.Fields.Add(new Field()
            {
                AccessModifier = AccessModifier.Private,
                Attributes = new() { RequiredInPrefabInstancesAttribute, AssetsOnlyAttribute, SerializeFieldAttribute },
                Name = service.ServiceType.Name.LowerFirst(),
                CustomDataType = service.ServiceType.ToDisplayString(),
            });
        }

        foreach (var service in prefabs)
        {
            classModel.Fields.Add(new Field()
            {
                AccessModifier = AccessModifier.Private,
                Attributes = new() { RequiredInPrefabInstancesAttribute, AssetsOnlyAttribute, SerializeFieldAttribute },
                Name = service.ServiceType.Name.LowerFirst(),
                CustomDataType = service.ServiceType.ToDisplayString(),
            });
        }

        var resetMethod = new Method()
        {
            AccessModifier = AccessModifier.Private,
            BuiltInDataType = BuiltInDataType.Void,
            BodyLines = new List<string>(),
            Name = "Reset"
        };
        resetMethod.BodyLines.Add("#if UNITY_EDITOR");

        // Register installer in the list of installers.
        resetMethod.BodyLines.Add("var sceneContext = GetComponent<SceneContext>();");
        resetMethod.BodyLines.AddRange(new[]
        {
                "if (sceneContext != null)",
                "{",
                CsGenerator.IndentSingle + "var listInstallers = new List<MonoInstaller>(sceneContext.Installers);",
                CsGenerator.IndentSingle + "if (listInstallers.IndexOf(this) == -1)",
                CsGenerator.IndentSingle + "{",
                CsGenerator.IndentSingle + CsGenerator.IndentSingle + "listInstallers.Add(this);",
                CsGenerator.IndentSingle + "}",
                CsGenerator.IndentSingle + "sceneContext.Installers = listInstallers;",
                "}",
            });

        foreach (var monoClassWithSceneObjInst in monoClassesWithSceneObjInstance)
        {
            resetMethod.BodyLines.Add($"{monoClassWithSceneObjInst.ServiceType.Name.LowerFirst()} = FindObjectOfType<{monoClassWithSceneObjInst.ServiceType.ToDisplayString()}>();");
        }

        foreach (var monoClassWithAssetInstance in monoClassesWithAssetInstance)
        {
            resetMethod.BodyLines.Add($"{monoClassWithAssetInstance.ServiceType.Name.LowerFirst()} = AssetDatabaseEx.GetSingleAssetsAtPath<{monoClassWithAssetInstance.ServiceType.ToDisplayString()}>();");
        }

        foreach (var prefab in prefabs)
        {
            resetMethod.BodyLines.Add($"{prefab.ServiceType.Name.LowerFirst()} = AssetDatabaseEx.GetSingleAssetsAtPath<{prefab.ServiceType.ToDisplayString()}>();");
        }

        resetMethod.BodyLines.Add("#endif");
        classModel.Methods.Add(resetMethod);


        var installBindingsMethod = new Method()
        {
            AccessModifier = AccessModifier.Public,
            Parameters = new(),
            BodyLines = new(),
            Name = "InstallBindings",
            BuiltInDataType = BuiltInDataType.Void,
            KeyWords = new() { KeyWord.Override }
        };
        if (monoClassesWithSceneObjInstance.Count > 0)
        {
            var installMethod = new Method()
            {
                AccessModifier = AccessModifier.Private,
                Parameters = new(),
                BodyLines = new(),
                Name = "InstallMonoClassesWithSceneObjInstance",
                BuiltInDataType = BuiltInDataType.Void,
            };
            installBindingsMethod.BodyLines.Add(installMethod.Name + "();");
            foreach (var service in monoClassesWithSceneObjInstance)
            {
                installMethod.BodyLines.Add(GenerateCall(service));
            }

            classModel.Methods.Add(installMethod);
        }

        if (monoClassesWithAssetInstance.Count > 0)
        {
            var installMethod = new Method()
            {
                AccessModifier = AccessModifier.Private,
                Parameters = new(),
                BodyLines = new(),
                Name = "InstallMonoClassesWithAssetInstance",
                BuiltInDataType = BuiltInDataType.Void,
            };
            installBindingsMethod.BodyLines.Add(installMethod.Name + "();");
            foreach (var service in monoClassesWithAssetInstance)
            {
                installMethod.BodyLines.Add(GenerateCall(service));
            }

            classModel.Methods.Add(installMethod);
        }

        if (classesWithoutInstance.Count > 0)
        {
            var installMethod = new Method()
            {
                AccessModifier = AccessModifier.Private,
                Parameters = new(),
                BodyLines = new(),
                Name = "InstallClassesWithoutInstance",
                BuiltInDataType = BuiltInDataType.Void,
            };
            installBindingsMethod.BodyLines.Add(installMethod.Name + "();");
            foreach (var service in classesWithoutInstance)
            {
                installMethod.BodyLines.Add(GenerateCall(service));
            }

            classModel.Methods.Add(installMethod);
        }

        if (prefabs.Count > 0)
        {
            var installMethod = new Method()
            {
                AccessModifier = AccessModifier.Private,
                Parameters = new(),
                BodyLines = new(),
                Name = "InstallPrefabs",
                BuiltInDataType = BuiltInDataType.Void,
            };
            installBindingsMethod.BodyLines.Add(installMethod.Name + "();");
            foreach (var service in prefabs)
            {
                var candidateConstructor = service.CandidateConstructors.FirstOrDefault();
                var typeNames = candidateConstructor?.Parameters.Select(_ => _.Type.ToDisplayString()) ?? Array.Empty<string>();
                var typeParameters = string.Join(", ", typeNames.Union(new[] { service.ServiceType.ToDisplayString() }));
                var call = $"Container.BindFactory<{typeParameters}, {service.ServiceType.ToDisplayString()}.Factory>().FromComponentInNewPrefab({service.ServiceType.Name.LowerFirst()}){service.Suffix};";
                installMethod.BodyLines.Add(call);
            }

            classModel.Methods.Add(installMethod);
        }

        if (signals.Count > 0)
        {
            var installMethod = new Method()
            {
                AccessModifier = AccessModifier.Private,
                Parameters = new(),
                BodyLines = new(),
                Name = "InstallSignals",
                BuiltInDataType = BuiltInDataType.Void,
            };
            installBindingsMethod.BodyLines.Add(installMethod.Name + "();");
            foreach (var service in signals)
            {
                installMethod.BodyLines.Add(GenerateCall(service));
            }

            classModel.Methods.Add(installMethod);
        }

        classModel.Methods.Add(installBindingsMethod);
        file.Classes.Add(classModel);

        if (prefabs.Count > 0)
        {
            foreach (var service in prefabs)
            {
                var candidateConstructor = service.CandidateConstructors.FirstOrDefault();
                var typeNames = candidateConstructor?.Parameters.Select(_ => _.Type.ToDisplayString()) ?? Array.Empty<string>();
                var typeParameters = string.Join(", ", typeNames.Union(new[] { service.ServiceType.ToDisplayString() }));
                var prefabClass = new ClassModel(service.ServiceType.Name)
                {
                    SingleKeyWord = KeyWord.Partial,
                    Namespace = service.ServiceType.ContainingNamespace.GetNamespace(),
                };
                var prefabFatory = new ClassModel("Factory")
                {
                    BaseClass = $"PlaceholderFactory<{typeParameters}>",
                };
                prefabClass.NestedClasses.Add(prefabFatory);
                file.Classes.Add(prefabClass);
            }
        }
        return file;
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private static string GenerateCall(ServiceDescriptor service)
    {
        if (service.InjectionMethod == InjectionMethod.Signal)
        {
            return $"Container.DeclareSignal<{service.ServiceType.ToDisplayString()}>(){service.Suffix};";
        }

        var bindMethod = service.BindInterfacesAndSelf ? "BindInterfacesAndSelfTo" : "Bind";
        string loadMethod = service.IsLazyLoading ? "Lazy" : "NonLazy";
        string optionalFromInstance = service.FromInstance ? $".FromInstance({service.ServiceType.Name.LowerFirst()})" : string.Empty;
        var call = $"Container.{bindMethod}<{service.ServiceType.ToDisplayString()}>(){optionalFromInstance}.AsSingle().{loadMethod}(){service.Suffix};";
        return call;
    }

    private static bool IsValidServiceClass(INamedTypeSymbol namedTypeSymbol)
    {
        var attribute = namedTypeSymbol.GetCustomAttribute(ZenGenAttributeType);
        if (attribute == null)
        {
            return false;
        }

        if (attribute.ConstructorArguments.Length != 5)
        {
            return false;
        }

        return true;
    }

    private static ServiceDescriptor GetServiceDescriptor(INamedTypeSymbol namedTypeSymbol)
    {
        var attribute = namedTypeSymbol.GetCustomAttribute(ZenGenAttributeType);
        var injectionMethod = (InjectionMethod)(int)attribute.ConstructorArguments[0].Value;
        var installerEnumValue = attribute.ConstructorArguments[1].Value is string installerName
            ? installerName
            : attribute.ConstructorArguments[1].ToCSharpString().Split('.').Last();
        var bindInterfacesAndSelf = (bool)attribute.ConstructorArguments[2].Value;
        var isLazyLoading = (bool)attribute.ConstructorArguments[3].Value;
        var suffix = (string)attribute.ConstructorArguments[4].Value;
        return new ServiceDescriptor
        {
            ServiceType = namedTypeSymbol,
            InjectionMethod = injectionMethod,
            BindInterfacesAndSelf = bindInterfacesAndSelf,
            IsLazyLoading = isLazyLoading,
            Suffix = suffix,
            TargetInstallerName = installerEnumValue,
        };
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> ServiceCandidates = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is not ClassDeclarationSyntax classDeclarationSyntax)
            {
                return;
            }

            var zenGenAttribute = classDeclarationSyntax.AttributeLists.FindAttribute(ZenGenAttributeType);
            if (zenGenAttribute == null)
            {
                return;
            }

            ServiceCandidates.Add(classDeclarationSyntax);
        }
    }
}
