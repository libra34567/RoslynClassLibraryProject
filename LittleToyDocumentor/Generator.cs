using CsCodeGenerator;
using CsCodeGenerator.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LittleToyDocumentor;

[Generator]
public class Generator : ISourceGenerator
{
    private const string FileHeader = @"// <auto-generated>
// Code generated by LittleToy Documentation Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
#nullable enable
#pragma warning disable 1591";

    private const string GenerateAuthoringComponentAttributeType = "GenerateAuthoringComponent";

    private static DiagnosticDescriptor ErrorComponentCall = new DiagnosticDescriptor(
        "LD1001",
        "Error call to component",
        "Error call to component with type {0} in method {1}",
        "LittleToysDocumentor",
        DiagnosticSeverity.Warning, isEnabledByDefault: true, description: "Use only types known by DOTSNET");

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
        {
            return;
        }

        if (context.Compilation.AssemblyName.StartsWith("Unity.", StringComparison.InvariantCultureIgnoreCase)
            || context.Compilation.AssemblyName.StartsWith("UnityEngine.", StringComparison.InvariantCultureIgnoreCase)
            || context.Compilation.AssemblyName.StartsWith("UnityEditor.", StringComparison.InvariantCultureIgnoreCase)
            || context.Compilation.AssemblyName.Equals("Unity", StringComparison.InvariantCultureIgnoreCase)
            || context.Compilation.AssemblyName.StartsWith("DOTSNET.", StringComparison.InvariantCultureIgnoreCase)
            || context.Compilation.AssemblyName.Equals("DOTSNET", StringComparison.InvariantCultureIgnoreCase))
        {
            // Ignore Unity and DOTSNET assemblies, mostly useful for debugging. Can unlock this, if need to generate docs on their classes.
            return;
        }

        var symbols = GetSymbols(context.Compilation, receiver.MemberAccessExpressionSyntaxes).Distinct().ToList();
        var authoringTypes = GetSymbols(context.Compilation, receiver.GenerateAuthoringComponentTypesSyntaxes).Distinct().ToList();
        var typeDocumentations = GetTypeDocumentations(symbols, authoringTypes, context);
        foreach (var typeInformation in typeDocumentations)
        {
            var type = typeInformation.Type;
            var typeName = type.Name;
            var file = new FileModel(typeName + "Documentation")
            {
                Header = FileHeader,
                Namespace = type.ContainingNamespace.GetNamespace(),
            };
            try
            {
                StringBuilder comment = new StringBuilder();
                bool firstOperation = true;
                foreach (var operationInformation in typeInformation.Descriptors.GroupBy(ti => ti.OperationName).OrderBy(_ => _.Key))
                {
                    if (!firstOperation)
                    {
                        comment.AppendLine();
                    }

                    string operationName = operationInformation.Key;
                    bool firstLine = true;
                    var callSites = operationInformation.Where(_ => _.Method is not null).Select(_ => (_.Method.Name, _.Method.ReceiverType)).Distinct();
                    foreach (var callSiteInformation in callSites.OrderBy(type => type.ReceiverType.Name).GroupBy(_ => _.ReceiverType))
                    {
                        var usedMethods = callSiteInformation.Select(_ => _.Name).OrderBy(_ => _);
                        if (firstLine)
                        {
                            comment.AppendLine($"{operationName} in {string.Join(", ", usedMethods)} of <see cref=\"{callSiteInformation.Key.ToDisplayString()}\"/>");
                            firstLine = false;
                        }
                        else
                        {
                            comment.AppendLine($"     in {string.Join(", ", usedMethods)} of <see cref=\"{callSiteInformation.Key.ToDisplayString()}\"/>");
                        }
                    }

                    var hasAuthoring = typeInformation.ViaAuthoring && operationName == "Added";
                    if (hasAuthoring)
                    {
                        if (firstLine)
                        {
                            comment.AppendLine($"{operationName} via authoring");
                        }
                        else
                        {
                            comment.AppendLine($"     and via authoring");
                        }
                    }

                    firstOperation = false;
                }

                if (type.IsValueType)
                {
                    file.Structs.Add(new StructModel(typeName)
                    {
                        Comment = comment.ToString(),
                        UseXmlDocCommentStyle = true,
                        SingleKeyWord = KeyWord.Partial,
                    });
                }
                else
                {
                    file.Classes.Add(new ClassModel(typeName)
                    {
                        Comment = comment.ToString(),
                        UseXmlDocCommentStyle = true,
                        SingleKeyWord = KeyWord.Partial,
                    });
                }
                context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
            }
            catch (Exception ex)
            {
                file.Classes.Add(new ClassModel(typeName)
                {
                    Comment = ex.ToString(),
                    UseXmlDocCommentStyle = true,
                    SingleKeyWord = KeyWord.Partial,
                });
                context.AddSource(file.Name, SourceText.From(file.ToString(), Encoding.UTF8));
            }
        }
    }

    private IEnumerable<TypeDocumentationModel> GetTypeDocumentations(IList<AuthoringDescriptor> memberCallsAuthoringDescriptors, IList<AuthoringDescriptor> authoringDescriptors, GeneratorExecutionContext context)
    {
        foreach (var typeInformation in memberCallsAuthoringDescriptors.Union(authoringDescriptors).GroupBy(s => s.Type))
        {
            if (typeInformation.Key.TypeKind == TypeKind.TypeParameter)
            {
                continue;
            }

            if (typeInformation.Key.TypeKind == TypeKind.Error)
            {
                context.ReportDiagnostic(Diagnostic.Create(ErrorComponentCall, location: null, typeInformation.Key, typeInformation.First().Method));
                continue;
            }

            var typeDeclarationSytaxes = typeInformation.Key.DeclaringSyntaxReferences.Select(_ => _.GetSyntax() as TypeDeclarationSyntax);
            var isPartial = typeDeclarationSytaxes.All(typeDeclarationSyntax => typeDeclarationSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)));
            if (!isPartial)
            {
                continue;
            }

            if (!SymbolEqualityComparer.Default.Equals(typeInformation.Key.ContainingAssembly, context.Compilation.Assembly))
            {
                // Skip type definitions from other assemblies, since we cannot generate anything for them.
                continue;
            }

            yield return new TypeDocumentationModel(typeInformation.Key, typeInformation.Distinct().ToArray());
        }
    }

    private IEnumerable<AuthoringDescriptor> GetSymbols(Compilation compilation, IList<MemberAccessExpressionSyntax> syntaxes)
    {
        foreach (var target in syntaxes)
        {
            var model = compilation.GetSemanticModel(target.SyntaxTree);
            var methodSymbol = model.GetSymbolInfo(target).Symbol as IMethodSymbol;
            if (!IsValidMethod(methodSymbol))
            {
                continue;
            }
            
            if (methodSymbol.IsGenericMethod)
            {
                var operationName = methodSymbol.Name.StartsWith("Add") ? "Added" : "Removed";
                var componentType = methodSymbol.TypeArguments[0];
                var methodDeclaration = FindMethodDeclaration(target);
                methodSymbol = model.GetDeclaredSymbol(methodDeclaration);
                yield return new (operationName, methodSymbol, componentType);
            }
            else
            {
                continue;
            }
        }
    }

    private IEnumerable<AuthoringDescriptor> GetSymbols(Compilation compilation, IList<StructDeclarationSyntax> syntaxes)
    {
        foreach (var target in syntaxes)
        {
            var model = compilation.GetSemanticModel(target.SyntaxTree);
            var componentType = model.GetDeclaredSymbol(target) as ITypeSymbol;
            if (componentType == null)
            {
                continue;
            }

            yield return new("Added", null, componentType);
        }
    }

    private static MethodDeclarationSyntax FindMethodDeclaration(SyntaxNode node)
    {
        while (node != null)
        {
            if (node is MethodDeclarationSyntax method)
            {
                return method;
            }

            node = node.Parent;
        }

        return null;
    }

    private static bool IsValidMethod(IMethodSymbol methodSymbol)
    {
        var type = methodSymbol.ReceiverType;
        var wellKnownTypes = new[] { "Unity.Entities.EntityManager", "Unity.Entities.EntityCommandBuffer", "Unity.Entities.EntityCommandBuffer.ParallelWriter" };
        if (!wellKnownTypes.Contains(type.ToDisplayString()))
        {
            return false;
        }

        var wellKnownMethods = new[] { "AddComponent", "AddComponentData", "RemoveComponent", "RemoveComponentData" };
        if (!wellKnownMethods.Contains(methodSymbol.Name))
        {
            return false;
        }

        return true;
    }

    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<MemberAccessExpressionSyntax> MemberAccessExpressionSyntaxes = new();
        public List<StructDeclarationSyntax> GenerateAuthoringComponentTypesSyntaxes = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is InvocationExpressionSyntax invocationExpressionSyntax)
            {
                if (invocationExpressionSyntax.Expression is MemberAccessExpressionSyntax memberAccessExpressionSyntax)
                {
                    if (memberAccessExpressionSyntax.OperatorToken.IsKind(SyntaxKind.DotToken) && 
                        (memberAccessExpressionSyntax.Name.ToFullString().StartsWith("AddComponent") || memberAccessExpressionSyntax.Name.ToFullString().StartsWith("RemoveComponent")))
                    {
                        MemberAccessExpressionSyntaxes.Add(memberAccessExpressionSyntax);
                    }
                }
            }

            // any field with at least one attribute is a candidate for property generation
            if (syntaxNode is StructDeclarationSyntax structDeclarationSyntax
                && structDeclarationSyntax.AttributeLists.Count > 0)
            {
                var generateAuthoringComponentAttribute = structDeclarationSyntax.AttributeLists.FindAttribute(GenerateAuthoringComponentAttributeType);
                if (generateAuthoringComponentAttribute != null)
                {
                    this.GenerateAuthoringComponentTypesSyntaxes.Add(structDeclarationSyntax);
                }
            }
        }
    }
}
